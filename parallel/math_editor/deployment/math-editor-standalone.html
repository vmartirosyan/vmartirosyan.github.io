<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math Expression Editor</title>
    <style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    padding: 20px;
}

.container {
    max-width: 1400px;
    margin: 0 auto;
}

header {
    background: white;
    padding: 20px 30px;
    border-radius: 15px 15px 0 0;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    position: relative;
    z-index: 100;
}

.header-top {
    margin-bottom: 15px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.language-selector select {
    padding: 8px 12px;
    border-radius: 8px;
    border: 2px solid #e0e0e0;
    background-color: white;
    font-size: 14px;
    cursor: pointer;
    outline: none;
    transition: border-color 0.3s;
}

.language-selector select:hover,
.language-selector select:focus {
    border-color: #667eea;
}

header h1 {
    color: #333;
    font-size: 28px;
    margin: 0;
}

.header-bottom {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 15px;
    position: relative;
    z-index: 101;
}

.tab-navigation {
    display: flex;
    gap: 10px;
    flex: 1;
    position: relative;
    z-index: 10;
}

.controls {
    display: flex;
    gap: 10px;
    position: relative;
    z-index: 10;
}

.control-btn {
    padding: 10px 20px;
    background: #667eea;
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    transition: all 0.3s ease;
}

.control-btn:hover {
    background: #5568d3;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
}

.control-btn:active {
    transform: translateY(0);
}

main {
    background: white;
    border-radius: 0 0 15px 15px;
    overflow: hidden;
    position: relative;
    z-index: 1;
}

/* Whiteboard Area */
.whiteboard-container {
    background: white;
    padding: 40px;
    min-height: 300px;
    border-bottom: 3px solid #f0f0f0;
}

.expression-display {
    background: #fafafa;
    border: 2px solid #e0e0e0;
    border-radius: 10px;
    min-height: 200px;
    padding: 30px;
    font-size: 32px;
    font-family: 'Cambria Math', 'Times New Roman', serif;
    position: relative;
    display: flex;
    align-items: center;
    align-content: flex-start;
    flex-wrap: wrap;
    gap: 0px;
    line-height: 1.8;
    overflow-wrap: break-word;
    word-wrap: break-word;
}

.expression-display:focus-within {
    border-color: #667eea;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}

/* Expression Elements */
.expr-element {
    display: inline-flex;
    align-items: center;
    position: relative;
    padding: 0px;
    margin: 0px;
    border-radius: 4px;
    transition: background 0.2s;
    vertical-align: middle;
}

.expr-element.focused {
    background: rgba(102, 126, 234, 0.1);
    outline: 2px solid #667eea;
}

.expr-number,
.expr-symbol {
    padding: 0px;
    margin: 0px;
    display: inline-flex;
    align-items: center;
}

.expr-operator {
    color: #333;
    font-weight: normal;
    margin: 0 6px;
    display: inline-flex;
    align-items: center;
    padding: 2px 4px;
}

/* Fraction */
.expr-fraction {
    display: inline-grid;
    grid-template-rows: auto 2px auto;
    align-items: stretch;
    vertical-align: middle;
    margin: 0 8px;
    position: relative;
    align-self: center;
    justify-items: stretch;
    font-size: 0.7em;
}

/* Nested fractions get progressively smaller */
.expr-fraction .expr-fraction {
    font-size: 0.8em;
}

.fraction-numerator {
    position: relative;
    padding: 4px 8px;
    text-align: center;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 2px;
    border: 1px dotted #ccc;
    border-radius: 3px;
    width: 100%;
    min-width: 30px;
    min-height: 30px;
    grid-row: 1;
}

/* Create the fraction line that scales with content */
.fraction-numerator::after {
    content: '';
    position: absolute;
    bottom: -3px;
    left: -8px;
    right: -8px;
    height: 2px;
    background: #333;
    pointer-events: none;
    z-index: 1;
}

.fraction-denominator {
    position: relative;
    padding: 4px 8px;
    text-align: center;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 2px;
    border: 1px dotted #ccc;
    border-radius: 3px;
    width: 100%;
    min-width: 30px;
    min-height: 30px;
    grid-row: 3;
}

.fraction-numerator.active,
.fraction-denominator.active {
    border-width: 2px;
    border-color: #667eea;
    background: rgba(102, 126, 234, 0.15);
    border-radius: 4px;
}

/* Create the fraction line between numerator and denominator - OLD APPROACH */
/* .expr-fraction::before {
    content: '';
    position: absolute;
    left: 0;
    right: 0;
    top: 50%;
    transform: translateY(-50%);
    height: 2px;
    background: #333;
    pointer-events: none;
    z-index: 1;
} */

.fraction-numerator.active,
.fraction-denominator.active {
    background: rgba(102, 126, 234, 0.15);
    border-radius: 4px;
}

/* Superscript & Subscript */
.expr-power,
.expr-subscript {
    display: inline-flex;
    align-items: center;
    position: relative;
    vertical-align: baseline;
}

.power-base,
.subscript-base {
    display: inline-flex;
    align-items: center;
    border: 1px dotted #ccc;
    border-radius: 3px;
    padding: 2px;
    min-width: 15px;
    min-height: 15px;
}

.power-base.active,
.subscript-base.active {
    border-width: 2px;
    border-color: #667eea;
    background: rgba(102, 126, 234, 0.15);
}

.power-exponent {
    font-size: 0.6em;
    margin-left: -1px;
    min-width: 15px;
    min-height: 15px;
    display: inline-flex;
    align-items: center;
    position: relative;
    top: -12px;
    border: 1px dotted #ccc;
    border-radius: 3px;
    padding: 2px;
}

.power-exponent.active {
    border-width: 2px;
    border-color: #667eea;
    background: rgba(102, 126, 234, 0.15);
}

.subscript-index {
    font-size: 0.6em;
    margin-left: -1px;
    min-width: 15px;
    min-height: 15px;
    display: inline-flex;
    align-items: center;
    position: relative;
    top: 8px;
    border: 1px dotted #ccc;
    border-radius: 3px;
    padding: 2px;
}

.subscript-index.active {
    border-width: 2px;
    border-color: #667eea;
    background: rgba(102, 126, 234, 0.15);
}

.power-exponent.active,
.subscript-index.active,
.power-base.active,
.subscript-base.active {
    background: rgba(102, 126, 234, 0.15);
    border-radius: 4px;
    padding: 2px 4px;
}

/* Square Root */
.expr-sqrt {
    display: inline-flex;
    align-items: stretch;
    position: relative;
    margin: 0 4px;
    vertical-align: middle;
}

.sqrt-radical-wrapper {
    display: flex;
    align-items: stretch;
    align-self: stretch;
    position: relative;
}

.sqrt-symbol {
    width: 28px;
    height: 100%;
    display: block;
}

.sqrt-content {
    padding: 8px 8px 4px 8px;
    min-width: 40px;
    min-height: 30px;
    display: inline-flex;
    align-items: center;
    position: relative;
    border-left: 1px dotted #ccc;
    border-right: 1px dotted #ccc;
    border-bottom: 1px dotted #ccc;
    border-radius: 0 3px 3px 0;
    margin-left: 0px;
}

/* Create the continuous top line (vinculum) */
.sqrt-content::before {
    content: '';
    position: absolute;
    top: 1px;
    left: -4px;
    right: -8px;
    height: 3px;
    background: #333;
    pointer-events: none;
    z-index: 1;
}

.sqrt-content.active {
    border-left-width: 2px;
    border-right-width: 2px;
    border-bottom-width: 2px;
    border-left-color: #667eea;
    border-right-color: #667eea;
    border-bottom-color: #667eea;
    background: rgba(102, 126, 234, 0.15);
    border-radius: 0 4px 4px 0;
}

/* Parentheses */
.expr-parens {
    display: inline-flex;
    align-items: center;
    font-size: 1.2em;
}

.parens-content {
    display: inline-flex;
    align-items: center;
    gap: 2px;
    border: 1px dotted #ccc;
    border-radius: 3px;
    padding: 2px;
    min-width: 20px;
    min-height: 20px;
}

.parens-content.active {
    border-width: 2px;
    border-color: #667eea;
    background: rgba(102, 126, 234, 0.15);
}

/* Line Break */
.expr-linebreak {
    flex-basis: 100%;
    height: 0;
    width: 100%;
}

/* Cursor */
.cursor {
    display: inline-flex;
    width: 3px;
    height: 36px;
    background: linear-gradient(to bottom, #667eea 0%, #5568d3 100%);
    margin: 0;
    opacity: 0;
    align-self: center;
    flex-shrink: 0;
    border-radius: 2px;
    box-shadow: 0 0 8px rgba(102, 126, 234, 0.6);
    position: relative;
    cursor: pointer;
}

.cursor.active {
    opacity: 1;
    animation: blink 1s infinite;
}

.cursor.active::before {
    content: '';
    position: absolute;
    top: -4px;
    left: 50%;
    transform: translateX(-50%);
    width: 0;
    height: 0;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-top: 6px solid #667eea;
}

.cursor.active::after {
    content: '';
    position: absolute;
    bottom: -4px;
    left: 50%;
    transform: translateX(-50%);
    width: 0;
    height: 0;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-bottom: 6px solid #667eea;
}

@keyframes blink {
    0%, 45% { 
        opacity: 1; 
        transform: scaleY(1);
    }
    50%, 95% { 
        opacity: 0.3;
        transform: scaleY(0.95);
    }
    100% { 
        opacity: 1;
        transform: scaleY(1);
    }
}

/* Keyboard */
.keyboard-container {
    background: #f8f9fa;
    padding: 30px;
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 20px;
}

.keyboard-section {
    background: white;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
}

.keyboard-section h3 {
    color: #333;
    margin-bottom: 15px;
    font-size: 16px;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.keyboard-row {
    display: flex;
    gap: 8px;
    margin-bottom: 8px;
    flex-wrap: wrap;
}

.keyboard-row:last-child {
    margin-bottom: 0;
}

.key-btn {
    flex: 1;
    min-width: 50px;
    padding: 15px 10px;
    background: #f0f0f0;
    border: 2px solid #e0e0e0;
    border-radius: 8px;
    font-size: 18px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    color: #333;
}

.key-btn:hover {
    background: #e8e8e8;
    border-color: #667eea;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.key-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.key-btn.number {
    background: #e3f2fd;
    border-color: #90caf9;
}

.key-btn.number:hover {
    background: #bbdefb;
}

.key-btn.operator {
    background: #fff3e0;
    border-color: #ffb74d;
    color: #e65100;
}

.key-btn.operator:hover {
    background: #ffe0b2;
}

.key-btn.function {
    background: #f3e5f5;
    border-color: #ce93d8;
    color: #6a1b9a;
}

.key-btn.function:hover {
    background: #e1bee7;
}

.key-btn.trig {
    background: #e8f5e9;
    border-color: #81c784;
    color: #2e7d32;
}

.key-btn.trig:hover {
    background: #c8e6c9;
}

.key-btn.symbol {
    background: #fce4ec;
    border-color: #f48fb1;
    color: #c2185b;
}

.key-btn.symbol:hover {
    background: #f8bbd0;
}

/* Navigation Help */
.navigation-help {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
}

.navigation-help h3 {
    color: white;
}

.navigation-help p {
    margin-bottom: 10px;
    font-size: 14px;
    line-height: 1.6;
}

.navigation-help kbd {
    background: rgba(255, 255, 255, 0.2);
    padding: 3px 8px;
    border-radius: 4px;
    font-family: monospace;
    font-weight: bold;
    border: 1px solid rgba(255, 255, 255, 0.3);
}

/* Responsive Design */
@media (max-width: 900px) {
    body {
        padding: 0;
        background: #f0f2f5;
    }

    .container {
        width: 100%;
        max-width: 100%;
        margin: 0;
    }

    header {
        padding: 10px 15px;
        border-radius: 0;
        position: sticky;
        top: 0;
        z-index: 1000;
    }

    .header-top {
        margin-bottom: 10px;
        flex-wrap: nowrap;
        gap: 10px;
    }

    header h1 {
        font-size: 18px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .language-selector select {
        padding: 6px 10px;
        font-size: 13px;
    }

    .header-bottom {
        flex-direction: column;
        gap: 10px;
        align-items: stretch;
    }

    .tab-navigation, .controls {
        width: 100%;
        overflow-x: auto;
        padding-bottom: 5px;
        -webkit-overflow-scrolling: touch;
        display: flex;
        gap: 8px;
        scrollbar-width: none; /* Firefox */
    }
    
    .tab-navigation::-webkit-scrollbar,
    .controls::-webkit-scrollbar {
        display: none; /* Chrome/Safari */
    }

    .tab-btn, .control-btn {
        white-space: nowrap;
        flex-shrink: 0;
        padding: 8px 12px;
        font-size: 13px;
        border-radius: 20px; /* Pill shape for mobile */
    }

    main {
        border-radius: 0;
        min-height: calc(100vh - 120px);
    }

    /* Editor Tab */
    .whiteboard-container {
        padding: 15px;
        min-height: 150px;
        border-bottom: 1px solid #e0e0e0;
    }

    .expression-display {
        font-size: 22px;
        min-height: 100px;
        padding: 15px;
    }

    .keyboard-container {
        padding: 10px;
        gap: 10px;
        grid-template-columns: 1fr;
        background: #fff;
    }

    .keyboard-section {
        padding: 10px;
        box-shadow: none;
        border: 1px solid #eee;
    }
    
    .keyboard-section h3 {
        font-size: 14px;
        margin-bottom: 10px;
    }

    .key-btn {
        padding: 12px 0;
        font-size: 16px;
        border-radius: 6px;
    }

    /* Graphing & Drawing Layouts */
    .graphing-container, 
    .drawing-container {
        flex-direction: column;
        height: auto;
        padding: 0;
    }

    .graphing-sidebar,
    .drawing-sidebar {
        width: 100%;
        max-height: none;
        margin-bottom: 0;
        padding: 15px;
        border-bottom: 1px solid #eee;
        background: #fff;
    }
    
    /* Make sidebar sections collapsible or compact */
    .graphing-section, .tool-section {
        margin-bottom: 15px;
        padding-bottom: 15px;
        border-bottom: 1px solid #f0f0f0;
    }
    
    .graphing-section:last-child, .tool-section:last-child {
        border-bottom: none;
        margin-bottom: 0;
        padding-bottom: 0;
    }

    .graphing-canvas-area,
    .drawing-canvas-wrapper {
        height: 50vh; /* Use viewport height */
        min-height: 300px;
        border-radius: 0;
        padding: 0;
    }
    
    #graphCanvas, #drawingCanvas, #transformCanvas {
        width: 100% !important;
        height: 100% !important;
    }
    
    /* Adjust 3D controls for mobile */
    .shape-controls-overlay {
        position: relative;
        top: 0;
        right: 0;
        width: 100%;
        background: #f8f9fa;
        padding: 10px;
        border-top: 1px solid #ddd;
    }
    
    .controls-panel {
        width: 100%;
        box-shadow: none;
        padding: 0;
        background: transparent;
    }
    
    /* Improve touch targets for sliders */
    input[type=range] {
        height: 25px; /* Larger touch target */
    }
}

@media (max-width: 480px) {
    .key-btn {
        font-size: 14px;
    }
    
    .keyboard-row {
        gap: 4px;
    }
}

/* Tab Navigation */
.tab-btn {
    padding: 10px 20px;
    background: #f0f0f0;
    color: #666;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    transition: all 0.3s ease;
    position: relative;
    z-index: 1000;
    pointer-events: auto;
    display: inline-block;
}

.tab-btn:hover {
    background: #e0e0e0;
}

.tab-btn.active {
    background: #667eea;
    color: white;
}

.tab-content {
    display: none;
}

.tab-content.active {
    display: block;
}

/* Graphing Container */
.graphing-container {
    display: flex;
    gap: 20px;
    height: calc(100vh - 250px);
    min-height: 500px;
}

.graphing-sidebar {
    width: 300px;
    background: #f8f9fa;
    padding: 20px;
    border-radius: 10px;
    overflow-y: auto;
}

.graphing-section {
    margin-bottom: 25px;
}

.graphing-section h3 {
    color: #333;
    font-size: 16px;
    margin-bottom: 12px;
    font-weight: 600;
}

.chart-type-grid,
.shape-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
}

.chart-btn,
.shape-btn {
    padding: 12px;
    background: white;
    border: 2px solid #e0e0e0;
    border-radius: 8px;
    cursor: pointer;
    font-size: 13px;
    font-weight: 500;
    transition: all 0.2s ease;
    color: #333;
}

.chart-btn:hover,
.shape-btn:hover {
    border-color: #667eea;
    background: #f0f4ff;
}

.chart-btn.active {
    background: #667eea;
    color: white;
    border-color: #667eea;
}

.graphing-canvas-area {
    flex: 1;
    background: white;
    border-radius: 10px;
    padding: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
}

#graphCanvas {
    max-width: 100%;
    max-height: 100%;
}

.input-group {
    margin-bottom: 12px;
}

.input-group label {
    display: block;
    font-size: 13px;
    color: #555;
    margin-bottom: 5px;
    font-weight: 500;
}

.input-group input {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid #ddd;
    border-radius: 6px;
    font-size: 14px;
}

.input-group input[type="range"] {
    padding: 0;
    width: calc(100% - 50px);
    display: inline-block;
    vertical-align: middle;
}

.input-group span {
    display: inline-block;
    width: 45px;
    text-align: right;
    font-size: 13px;
    color: #666;
    margin-left: 5px;
}

.input-group input:focus {
    outline: none;
    border-color: #667eea;
}

.input-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
}

#plotBtn,
#plotChartBtn,
#renderShapeBtn {
    width: 100%;
    margin-top: 10px;
    padding: 10px;
    font-size: 14px;
}

/* 3D Controls Overlay */
.shape-controls-overlay {
    position: absolute;
    top: 20px;
    right: 20px;
    z-index: 10;
}

.controls-panel {
    background: white;
    border-radius: 10px;
    padding: 15px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    min-width: 220px;
}

.controls-panel h4 {
    margin: 0 0 15px 0;
    font-size: 14px;
    color: #333;
    font-weight: 600;
}

.control-item {
    margin-bottom: 12px;
}

.control-item label {
    display: block;
    font-size: 12px;
    color: #555;
    margin-bottom: 5px;
    font-weight: 500;
}

.control-item span {
    float: right;
    color: #667eea;
    font-weight: 600;
}

.control-item input[type="range"] {
    width: 100%;
    margin: 0;
}

.small-btn {
    width: 100%;
    padding: 8px;
    font-size: 13px;
    margin-top: 5px;
}

/* 2D Shape buttons */
.shape-2d-btn {
    padding: 12px;
    background: white;
    border: 2px solid #e0e0e0;
    border-radius: 8px;
    cursor: pointer;
    font-size: 13px;
    font-weight: 500;
    transition: all 0.2s ease;
    color: #333;
}

.shape-2d-btn:hover {
    border-color: #667eea;
    background: #f0f4ff;
}

.shape-2d-btn.active {
    background: #667eea;
    color: white;
    border-color: #667eea;
}

.transformation-controls,
.reflection-controls {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.transform-btn {
    padding: 10px;
    background: white;
    border: 1px solid #ddd;
    border-radius: 6px;
    cursor: pointer;
    font-size: 13px;
    transition: all 0.2s ease;
    color: #333;
}

.transform-btn:hover {
    background: #f0f4ff;
    border-color: #667eea;
}

.transform-btn:active {
    background: #667eea;
    color: white;
}

#customPoints {
    width: 100%;
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 6px;
    font-family: monospace;
    font-size: 13px;
    resize: vertical;
}

#customPoints:focus {
    outline: none;
    border-color: #667eea;
}

/* Drawing Tab Styles */
.drawing-container {
    display: flex;
    gap: 20px;
    height: calc(100vh - 250px);
    min-height: 500px;
    padding: 20px;
}

.drawing-sidebar {
    width: 250px;
    background: #f9f9f9;
    padding: 20px;
    border-radius: 10px;
    overflow-y: auto;
    flex-shrink: 0;
}

.drawing-sidebar h3 {
    color: #333;
    font-size: 20px;
    margin-bottom: 20px;
}

.tool-section {
    margin-bottom: 25px;
}

.tool-section h4 {
    color: #666;
    font-size: 14px;
    margin-bottom: 10px;
    font-weight: 600;
}

.tool-btn {
    width: 100%;
    padding: 12px;
    margin-bottom: 8px;
    background: white;
    color: #333;
    border: 2px solid #ddd;
    border-radius: 8px;
    cursor: pointer;
    font-size: 14px;
    text-align: left;
    transition: all 0.3s ease;
}

.tool-btn:hover {
    background: #f0f4ff;
    border-color: #667eea;
}

.tool-btn.active {
    background: #667eea;
    color: white;
    border-color: #667eea;
}

.action-btn {
    width: 100%;
    padding: 10px;
    margin-bottom: 8px;
    background: white;
    color: #333;
    border: 2px solid #ddd;
    border-radius: 8px;
    cursor: pointer;
    font-size: 13px;
    text-align: left;
    transition: all 0.3s ease;
}

.action-btn:hover {
    background: #667eea;
    color: white;
    border-color: #667eea;
}

#drawingColor {
    width: 100%;
    height: 40px;
    border: 2px solid #ddd;
    border-radius: 8px;
    cursor: pointer;
}

#brushSize {
    width: 100%;
}

.drawing-canvas-wrapper {
    flex: 1;
    background: white;
    border-radius: 10px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    overflow: hidden;
    position: relative;
}

#drawingCanvas {
    width: 100%;
    height: 100%;
    cursor: crosshair;
}

/* Evaluation Result */
.evaluation-result {
    margin-top: 15px;
    padding: 15px;
    background: #e8f5e9;
    border: 1px solid #c8e6c9;
    border-radius: 8px;
    color: #2e7d32;
    font-size: 18px;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 10px;
}

.evaluation-result.error {
    background: #ffebee;
    border-color: #ffcdd2;
    color: #c62828;
}
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-top">
                <h1 data-i18n="appTitle">Math Expression Editor</h1>
                <div class="language-selector">
                    <select id="languageSelect">
                        <option value="en">üá∫üá∏ English</option>
                        <option value="hy">üá¶üá≤ ’Ä’°’µ’•÷Ä’•’∂</option>
                    </select>
                </div>
            </div>
            <div class="header-bottom">
                <div class="tab-navigation">
                    <button class="tab-btn active" data-tab="editor" data-i18n="tabEditor">Expression Editor</button>
                    <button class="tab-btn" data-tab="graphing" data-i18n="tabGraphing">Graphing & 3D Shapes</button>
                    <button class="tab-btn" data-tab="transformations" data-i18n="tabTransformations">2D Transformations</button>
                    <button class="tab-btn" data-tab="drawing" data-i18n="tabDrawing">Freeform Drawing</button>
                </div>
                <div class="controls">
                    <button id="clearBtn" class="control-btn" data-i18n="clear">Clear</button>
                    <button id="undoBtn" class="control-btn" data-i18n="undo">Undo</button>
                    <button id="exportBtn" class="control-btn" data-i18n="exportLatex">Export LaTeX</button>
                    <button id="exportJpegBtn" class="control-btn" data-i18n="exportJpeg">Export JPEG</button>
                    <button id="importJpegBtn" class="control-btn" data-i18n="importJpeg">Import from JPEG</button>
                    <button id="evaluateBtn" class="control-btn" data-i18n="evaluate">Evaluate</button>
                    <input type="file" id="jpegFileInput" accept="image/jpeg" style="display: none;">
                </div>
            </div>
        </header>

        <main>
            <!-- Expression Editor Tab -->
            <div id="editorTab" class="tab-content active">
            <div class="whiteboard-container">
                <div id="expressionDisplay" class="expression-display">
                    <span class="cursor active" data-position="0"></span>
                </div>
                <div id="evaluationResult" class="evaluation-result" style="display: none;">
                    <span data-i18n="result">Result: </span><span id="resultValue"></span>
                </div>
            </div>

            <div class="keyboard-container">
                <div class="keyboard-section">
                    <h3 data-i18n="secNumbers">Numbers</h3>
                    <div class="keyboard-row">
                        <button class="key-btn number" data-value="7">7</button>
                        <button class="key-btn number" data-value="8">8</button>
                        <button class="key-btn number" data-value="9">9</button>
                        <button class="key-btn operator" data-value="/">√∑</button>
                        <button class="key-btn function" data-value="sqrt">‚àö</button>
                    </div>
                    <div class="keyboard-row">
                        <button class="key-btn number" data-value="4">4</button>
                        <button class="key-btn number" data-value="5">5</button>
                        <button class="key-btn number" data-value="6">6</button>
                        <button class="key-btn operator" data-value="*">√ó</button>
                        <button class="key-btn function" data-value="power">x^y</button>
                    </div>
                    <div class="keyboard-row">
                        <button class="key-btn number" data-value="1">1</button>
                        <button class="key-btn number" data-value="2">2</button>
                        <button class="key-btn number" data-value="3">3</button>
                        <button class="key-btn operator" data-value="-">‚àí</button>
                        <button class="key-btn function" data-value="log">log</button>
                    </div>
                    <div class="keyboard-row">
                        <button class="key-btn number" data-value="0">0</button>
                        <button class="key-btn number" data-value=".">.</button>
                        <button class="key-btn symbol" data-value="¬±">¬±</button>
                        <button class="key-btn operator" data-value="=">=</button>
                        <button class="key-btn operator" data-value="+">+</button>
                        <button class="key-btn function" data-value="ln">ln</button>
                    </div>
                </div>

                <div class="keyboard-section">
                    <h3 data-i18n="secSpecialFunctions">Special Functions</h3>
                    <div class="keyboard-row">
                        <button class="key-btn function" data-value="fraction">a/b</button>
                        <button class="key-btn function" data-value="subscript">x_i</button>
                        <button class="key-btn function" data-value="superscript">x^i</button>
                        <button class="key-btn function" data-value="integral">‚à´</button>
                    </div>
                    <div class="keyboard-row">
                        <button class="key-btn function" data-value="sum">Œ£</button>
                        <button class="key-btn function" data-value="product">Œ†</button>
                        <button class="key-btn function" data-value="limit">lim</button>
                        <button class="key-btn function" data-value="derivative">d/dx</button>
                    </div>
                    <div class="keyboard-row">
                        <button class="key-btn trig" data-value="sin">sin</button>
                        <button class="key-btn trig" data-value="cos">cos</button>
                        <button class="key-btn trig" data-value="tan">tan</button>
                        <button class="key-btn function" data-value="abs">|x|</button>
                    </div>
                </div>

                <div class="keyboard-section">
                    <h3 data-i18n="secLatinLetters">Latin Letters</h3>
                    <div class="keyboard-row" id="latinLettersRow">
                        <button class="key-btn symbol" data-value="a">a</button>
                        <button class="key-btn symbol" data-value="b">b</button>
                        <button class="key-btn symbol" data-value="c">c</button>
                        <button class="key-btn symbol" data-value="x">x</button>
                        <button class="key-btn symbol" data-value="y">y</button>
                        <button class="key-btn symbol" data-value="z">z</button>
                        <button class="key-btn control-btn" id="expandLatinBtn" style="font-size: 14px;" data-i18n="btnShowAll">Show All</button>
                    </div>
                    <div id="allLatinLetters" style="display: none;">
                        <div class="keyboard-row">
                            <button class="key-btn symbol" data-value="d">d</button>
                            <button class="key-btn symbol" data-value="e">e</button>
                            <button class="key-btn symbol" data-value="f">f</button>
                            <button class="key-btn symbol" data-value="g">g</button>
                            <button class="key-btn symbol" data-value="h">h</button>
                        </div>
                        <div class="keyboard-row">
                            <button class="key-btn symbol" data-value="i">i</button>
                            <button class="key-btn symbol" data-value="j">j</button>
                            <button class="key-btn symbol" data-value="k">k</button>
                            <button class="key-btn symbol" data-value="l">l</button>
                            <button class="key-btn symbol" data-value="m">m</button>
                        </div>
                        <div class="keyboard-row">
                            <button class="key-btn symbol" data-value="n">n</button>
                            <button class="key-btn symbol" data-value="o">o</button>
                            <button class="key-btn symbol" data-value="p">p</button>
                            <button class="key-btn symbol" data-value="q">q</button>
                            <button class="key-btn symbol" data-value="r">r</button>
                        </div>
                        <div class="keyboard-row">
                            <button class="key-btn symbol" data-value="s">s</button>
                            <button class="key-btn symbol" data-value="t">t</button>
                            <button class="key-btn symbol" data-value="u">u</button>
                            <button class="key-btn symbol" data-value="v">v</button>
                            <button class="key-btn symbol" data-value="w">w</button>
                        </div>
                    </div>
                </div>

                <div class="keyboard-section">
                    <h3 data-i18n="secGreekSymbols">Greek & Symbols</h3>
                    <div class="keyboard-row">
                        <button class="key-btn symbol" data-value="pi">œÄ</button>
                        <button class="key-btn symbol" data-value="theta">Œ∏</button>
                        <button class="key-btn symbol" data-value="alpha">Œ±</button>
                        <button class="key-btn symbol" data-value="beta">Œ≤</button>
                        <button class="key-btn symbol" data-value="gamma">Œ≥</button>
                    </div>
                    <div class="keyboard-row">
                        <button class="key-btn symbol" data-value="delta">Œ¥</button>
                        <button class="key-btn symbol" data-value="epsilon">Œµ</button>
                        <button class="key-btn symbol" data-value="lambda">Œª</button>
                        <button class="key-btn symbol" data-value="mu">Œº</button>
                        <button class="key-btn symbol" data-value="sigma">œÉ</button>
                    </div>
                    <div class="keyboard-row">
                        <button class="key-btn symbol" data-value="(">(</button>
                        <button class="key-btn symbol" data-value=")">)</button>
                        <button class="key-btn symbol" data-value="[">[</button>
                        <button class="key-btn symbol" data-value="]">]</button>
                        <button class="key-btn symbol" data-value=",">,</button>
                    </div>
                </div>

                <div class="keyboard-section navigation-help">
                    <h3 data-i18n="secNavigation">Navigation</h3>
                    <p><kbd>Arrow Keys</kbd> <span data-i18n="navHelp1">to navigate between expression elements</span></p>
                    <p><kbd>Tab</kbd> / <kbd>Shift+Tab</kbd> <span data-i18n="navHelp2">to move between sub-elements</span></p>
                    <p><kbd>Backspace</kbd> <span data-i18n="navHelp3">to delete ‚Ä¢ Esc to exit sub-element</span></p>
                    <p><kbd>Enter</kbd> <span data-i18n="navHelp4">to insert line break for multiline expressions</span></p>
                </div>
            </div>
            </div>
            <!-- End Expression Editor Tab -->

            <!-- Graphing Tab -->
            <div id="graphingTab" class="tab-content">
                <div class="graphing-container">
                    <div class="graphing-sidebar">
                        <div class="graphing-section">
                            <h3 data-i18n="secChartType">Chart Type</h3>
                            <div class="chart-type-grid">
                                <button class="chart-btn active" data-chart="function" data-i18n="btnFunctionGraph">Function Graph</button>
                                <button class="chart-btn" data-chart="bar" data-i18n="btnBarChart">Bar Chart</button>
                                <button class="chart-btn" data-chart="line" data-i18n="btnLineChart">Line Chart</button>
                                <button class="chart-btn" data-chart="pie" data-i18n="btnPieChart">Pie Chart</button>
                            </div>
                        </div>

                        <div class="graphing-section">
                            <h3 data-i18n="sec3DShapes">3D Shapes</h3>
                            <div class="shape-grid">
                                <button class="shape-btn" data-shape="pyramid" data-i18n="btnPyramid">Pyramid</button>
                                <button class="shape-btn" data-shape="cube" data-i18n="btnCube">Cube</button>
                                <button class="shape-btn" data-shape="cylinder" data-i18n="btnCylinder">Cylinder</button>
                                <button class="shape-btn" data-shape="cuboid" data-i18n="btnCuboid">Cuboid</button>
                                <button class="shape-btn" data-shape="sphere" data-i18n="btnSphere">Sphere</button>
                                <button class="shape-btn" data-shape="cone" data-i18n="btnCone">Cone</button>
                            </div>
                        </div>

                        <div class="graphing-section" id="functionInputSection">
                            <h3 data-i18n="secFunctionInput">Function Input</h3>
                            <div class="input-group">
                                <label for="functionInput">f(x) =</label>
                                <input type="text" id="functionInput" placeholder="e.g., x^2, sin(x), x^3 - 2*x">
                            </div>
                            <div class="input-row">
                                <div class="input-group">
                                    <label for="xMin" data-i18n="lblXMin">X Min:</label>
                                    <input type="number" id="xMin" value="-10" step="0.5">
                                </div>
                                <div class="input-group">
                                    <label for="xMax" data-i18n="lblXMax">X Max:</label>
                                    <input type="number" id="xMax" value="10" step="0.5">
                                </div>
                            </div>
                            <div class="input-row">
                                <div class="input-group">
                                    <label for="yMin" data-i18n="lblYMin">Y Min:</label>
                                    <input type="number" id="yMin" value="-10" step="0.5">
                                </div>
                                <div class="input-group">
                                    <label for="yMax" data-i18n="lblYMax">Y Max:</label>
                                    <input type="number" id="yMax" value="10" step="0.5">
                                </div>
                            </div>
                            <button id="plotBtn" class="control-btn" data-i18n="btnPlotGraph">Plot Graph</button>
                        </div>

                        <div class="graphing-section" id="chartDataSection" style="display: none;">
                            <h3 data-i18n="secChartData">Chart Data</h3>
                            <div class="input-group">
                                <label data-i18n="lblLabels">Labels (comma-separated):</label>
                                <input type="text" id="chartLabels" placeholder="A, B, C, D">
                            </div>
                            <div class="input-group">
                                <label data-i18n="lblValues">Values (comma-separated):</label>
                                <input type="text" id="chartValues" placeholder="10, 20, 15, 25">
                            </div>
                            <button id="plotChartBtn" class="control-btn" data-i18n="btnPlotChart">Plot Chart</button>
                        </div>

                        <div class="graphing-section" id="shapeParamsSection" style="display: none;">
                            <h3 data-i18n="secShapeParams">Shape Parameters</h3>
                            <div id="shapeInputs"></div>
                            <button id="renderShapeBtn" class="control-btn" data-i18n="btnRenderShape">Render Shape</button>
                        </div>
                    </div>

                    <div class="graphing-canvas-area">
                        <canvas id="graphCanvas"></canvas>
                        <div id="shape3DControls" class="shape-controls-overlay" style="display: none;">
                            <div class="controls-panel">
                                <h4 data-i18n="sec3DControls">3D Controls</h4>
                                <div class="control-item">
                                    <label><span data-i18n="lblRotationX">Rotation X:</span> <span id="rotationXValue">30¬∞</span></label>
                                    <input type="range" id="rotationX" min="0" max="360" value="30" step="5">
                                </div>
                                <div class="control-item">
                                    <label><span data-i18n="lblRotationY">Rotation Y:</span> <span id="rotationYValue">45¬∞</span></label>
                                    <input type="range" id="rotationY" min="0" max="360" value="45" step="5">
                                </div>
                                <div class="control-item">
                                    <label><span data-i18n="lblRotationZ">Rotation Z:</span> <span id="rotationZValue">0¬∞</span></label>
                                    <input type="range" id="rotationZ" min="0" max="360" value="0" step="5">
                                </div>
                                <div class="control-item">
                                    <label><span data-i18n="lblZoom">Zoom:</span> <span id="zoomValue">100%</span></label>
                                    <input type="range" id="zoomLevel" min="50" max="200" value="100" step="5">
                                </div>
                                <button id="reset3DBtn" class="control-btn small-btn" data-i18n="btnResetView">Reset View</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- End Graphing Tab -->
            
            <!-- 2D Transformations Tab -->
            <div id="transformationsTab" class="tab-content">
                <div class="graphing-container">
                    <div class="graphing-sidebar">
                        <div class="graphing-section">
                            <h3 data-i18n="sec2DShape">2D Shape</h3>
                            <div class="shape-grid">
                                <button class="shape-2d-btn active" data-shape="triangle" data-i18n="btnTriangle">Triangle</button>
                                <button class="shape-2d-btn" data-shape="square" data-i18n="btnSquare">Square</button>
                                <button class="shape-2d-btn" data-shape="rectangle" data-i18n="btnRectangle">Rectangle</button>
                                <button class="shape-2d-btn" data-shape="circle" data-i18n="btnCircle">Circle</button>
                                <button class="shape-2d-btn" data-shape="polygon" data-i18n="btnPolygon">Polygon</button>
                                <button class="shape-2d-btn" data-shape="custom" data-i18n="btnCustomPoints">Custom Points</button>
                            </div>
                        </div>

                        <div class="graphing-section">
                            <h3 data-i18n="secTransformations">Transformations</h3>
                            <div class="transformation-controls">
                                <div class="control-item">
                                    <label><span data-i18n="lblTransX">Translation X:</span> <span id="transXValue">0</span></label>
                                    <input type="range" id="translationX" min="-10" max="10" value="0" step="0.5">
                                </div>
                                <div class="control-item">
                                    <label><span data-i18n="lblTransY">Translation Y:</span> <span id="transYValue">0</span></label>
                                    <input type="range" id="translationY" min="-10" max="10" value="0" step="0.5">
                                </div>
                                <div class="control-item">
                                    <label><span data-i18n="lblRotation">Rotation:</span> <span id="rotation2DValue">0¬∞</span></label>
                                    <input type="range" id="rotation2D" min="0" max="360" value="0" step="5">
                                </div>
                                <div class="control-item">
                                    <label><span data-i18n="lblScale">Scale:</span> <span id="scaleValue">1</span></label>
                                    <input type="range" id="scale2D" min="0.5" max="3" value="1" step="0.1">
                                </div>
                            </div>
                            
                            <h4 style="margin-top: 15px; font-size: 13px;" data-i18n="lblRotCenter">Rotation Center</h4>
                            <div class="transformation-controls">
                                <div class="control-item">
                                    <label><span data-i18n="lblCenterX">Center X:</span> <span id="rotCenterXValue">0</span></label>
                                    <input type="range" id="rotationCenterX" min="-10" max="10" value="0" step="0.5">
                                </div>
                                <div class="control-item">
                                    <label><span data-i18n="lblCenterY">Center Y:</span> <span id="rotCenterYValue">0</span></label>
                                    <input type="range" id="rotationCenterY" min="-10" max="10" value="0" step="0.5">
                                </div>
                                <button class="transform-btn" id="setCenterToShape" data-i18n="btnCenterAtShape">Center at Shape</button>
                            </div>
                        </div>

                        <div class="graphing-section">
                            <h3 data-i18n="secReflections">Reflections</h3>
                            <div class="reflection-controls">
                                <button class="transform-btn" id="reflectX" data-i18n="btnReflectX">Reflect in X-axis</button>
                                <button class="transform-btn" id="reflectY" data-i18n="btnReflectY">Reflect in Y-axis</button>
                                <button class="transform-btn" id="reflectOrigin" data-i18n="btnReflectOrigin">Reflect in Origin</button>
                                <button class="transform-btn" id="reflectYeqX" data-i18n="btnReflectYeqX">Reflect in y=x</button>
                            </div>
                        </div>

                        <div class="graphing-section">
                            <h3 data-i18n="secSpecialTrans">Special Transformations</h3>
                            <div class="reflection-controls">
                                <button class="transform-btn" id="shearX" data-i18n="btnShearX">Shear X</button>
                                <button class="transform-btn" id="shearY" data-i18n="btnShearY">Shear Y</button>
                                <button class="transform-btn" id="rotate90" data-i18n="btnRotate90">Rotate 90¬∞</button>
                                <button class="transform-btn" id="rotate180" data-i18n="btnRotate180">Rotate 180¬∞</button>
                            </div>
                        </div>

                        <div class="graphing-section">
                            <h3 data-i18n="secActions">Actions</h3>
                            <div class="reflection-controls">
                                <button class="control-btn" id="showOriginal" data-i18n="btnToggleOriginal">Toggle Original</button>
                                <button class="control-btn" id="showGrid" data-i18n="btnToggleGrid">Toggle Grid</button>
                                <button class="control-btn" id="resetTransform" data-i18n="btnResetAll">Reset All</button>
                            </div>
                        </div>

                        <div class="graphing-section" id="customPointsSection" style="display: none;">
                            <h3 data-i18n="secCustomPoints">Custom Points</h3>
                            <div class="input-group">
                                <label data-i18n="lblPoints">Points (x,y pairs):</label>
                                <textarea id="customPoints" rows="4" placeholder="0,0&#10;2,0&#10;2,2&#10;0,2"></textarea>
                            </div>
                            <button class="control-btn" id="applyPoints" data-i18n="btnApplyPoints">Apply Points</button>
                        </div>
                    </div>

                    <div class="graphing-canvas-area">
                        <canvas id="transformCanvas"></canvas>
                    </div>
                </div>
            </div>
            <!-- End 2D Transformations Tab -->

            <!-- Freeform Drawing Tab -->
            <div id="drawingTab" class="tab-content">
                <div class="drawing-container">
                    <div class="drawing-sidebar">
                        <h3 data-i18n="secDrawingTools">Drawing Tools</h3>
                        
                        <div class="tool-section">
                            <h4 data-i18n="secTool">Tool</h4>
                            <button class="tool-btn active" data-tool="pen" data-i18n="btnPen">‚úèÔ∏è Pen</button>
                            <button class="tool-btn" data-tool="eraser" data-i18n="btnEraser">üßπ Eraser</button>
                            <button class="tool-btn" data-tool="line" data-i18n="btnLine">üìè Line</button>
                            <button class="tool-btn" data-tool="rectangle" data-i18n="btnRect">‚ñ≠ Rectangle</button>
                            <button class="tool-btn" data-tool="circle" data-i18n="btnCircleTool">‚≠ï Circle</button>
                            <button class="tool-btn" data-tool="text" data-i18n="btnText">üìù Text</button>
                        </div>

                        <div class="tool-section">
                            <h4 data-i18n="secColor">Color</h4>
                            <input type="color" id="drawingColor" value="#000000">
                        </div>

                        <div class="tool-section">
                            <h4><span data-i18n="secBrushSize">Brush Size:</span> <span id="brushSizeValue">3</span>px</h4>
                            <input type="range" id="brushSize" min="1" max="20" value="3" step="1">
                        </div>

                        <div class="tool-section">
                            <h4 data-i18n="secBackground">Background</h4>
                            <button class="action-btn" id="setBgWhite" data-i18n="btnWhite">‚¨ú White</button>
                            <button class="action-btn" id="setBgBlack" data-i18n="btnBlack">‚¨õ Black</button>
                            <button class="action-btn" id="setBgTransparent" data-i18n="btnTransparent">üî≤ Transparent</button>
                        </div>

                        <div class="tool-section">
                            <h4 data-i18n="secGrid">Grid</h4>
                            <button class="action-btn" id="toggleGrid" data-i18n="btnToggleGridDraw">üìê Toggle Grid</button>
                            <label style="font-size: 12px; color: #666; margin-top: 8px; display: block;">
                                <span data-i18n="lblGridSize">Grid Size:</span> <span id="gridSizeValue">20</span>px
                            </label>
                            <input type="range" id="gridSize" min="10" max="50" value="20" step="5">
                        </div>

                        <div class="tool-section">
                            <h4 data-i18n="secActions">Actions</h4>
                            <button class="action-btn" id="clearDrawing" data-i18n="btnClearCanvas">üóëÔ∏è Clear Canvas</button>
                            <button class="action-btn" id="undoDrawing" data-i18n="btnUndoDraw">‚Ü©Ô∏è Undo</button>
                            <button class="action-btn" id="saveDrawing" data-i18n="btnSavePng">üíæ Save PNG</button>
                        </div>
                    </div>
                    
                    <div class="drawing-canvas-wrapper">
                        <canvas id="drawingCanvas"></canvas>
                    </div>
                </div>
            </div>
            <!-- End Freeform Drawing Tab -->
        </main>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
    <script src="translations.js"></script>
    <script src="mathExpression.js"></script>
    <script src="navigation.js"></script>
    <script src="keyboard.js"></script>
    <script src="graphing.js"></script>
    <script src="transformations.js"></script>
    <script src="drawing.js"></script>
    <script src="app.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
    <script>
const translations = {
    en: {
        // Header & Tabs
        "appTitle": "Math Expression Editor",
        "tabEditor": "Expression Editor",
        "tabGraphing": "Graphing & 3D Shapes",
        "tabTransformations": "2D Transformations",
        "tabDrawing": "Freeform Drawing",
        
        // Controls
        "clear": "Clear",
        "undo": "Undo",
        "exportLatex": "Export LaTeX",
        "exportJpeg": "Export JPEG",
        "importJpeg": "Import from JPEG",
        "evaluate": "Evaluate",
        "result": "Result: ",
        "msgEvalError": "Evaluation Error: ",
        
        // Editor
        "secNumbers": "Numbers",
        "secSpecialFunctions": "Special Functions",
        "secLatinLetters": "Latin Letters",
        "secGreekSymbols": "Greek & Symbols",
        "secNavigation": "Navigation",
        "btnShowAll": "Show All",
        "btnShowLess": "Show Less",
        "navHelp1": "Use Arrow Keys to navigate between expression elements",
        "navHelp2": "Tab / Shift+Tab to move between sub-elements",
        "navHelp3": "Backspace to delete ‚Ä¢ Esc to exit sub-element",
        "navHelp4": "Enter to insert line break for multiline expressions",
        
        // Graphing
        "secChartType": "Chart Type",
        "btnFunctionGraph": "Function Graph",
        "btnBarChart": "Bar Chart",
        "btnLineChart": "Line Chart",
        "btnPieChart": "Pie Chart",
        "sec3DShapes": "3D Shapes",
        "sec3DControls": "3D Controls",
        "btnPyramid": "Pyramid",
        "btnCube": "Cube",
        "btnCylinder": "Cylinder",
        "btnCuboid": "Cuboid",
        "btnSphere": "Sphere",
        "btnCone": "Cone",
        "secFunctionInput": "Function Input",
        "lblXMin": "X Min:",
        "lblXMax": "X Max:",
        "lblYMin": "Y Min:",
        "lblYMax": "Y Max:",
        "btnPlotGraph": "Plot Graph",
        "secChartData": "Chart Data",
        "lblLabels": "Labels (comma-separated):",
        "lblValues": "Values (comma-separated):",
        "btnPlotChart": "Plot Chart",
        "secShapeParams": "Shape Parameters",
        "btnRenderShape": "Render Shape",
        "lblRotationX": "Rotation X:",
        "lblRotationY": "Rotation Y:",
        "lblRotationZ": "Rotation Z:",
        "lblZoom": "Zoom:",
        "btnResetView": "Reset View",
        
        // Transformations
        "sec2DShape": "2D Shape",
        "btnTriangle": "Triangle",
        "btnSquare": "Square",
        "btnRectangle": "Rectangle",
        "btnCircle": "Circle",
        "btnPolygon": "Polygon",
        "btnCustomPoints": "Custom Points",
        "secTransformations": "Transformations",
        "lblTransX": "Translation X:",
        "lblTransY": "Translation Y:",
        "lblRotation": "Rotation:",
        "lblScale": "Scale:",
        "lblRotCenter": "Rotation Center",
        "lblCenterX": "Center X:",
        "lblCenterY": "Center Y:",
        "btnCenterAtShape": "Center at Shape",
        "secReflections": "Reflections",
        "btnReflectX": "Reflect in X-axis",
        "btnReflectY": "Reflect in Y-axis",
        "btnReflectOrigin": "Reflect in Origin",
        "btnReflectYeqX": "Reflect in y=x",
        "secSpecialTrans": "Special Transformations",
        "btnShearX": "Shear X",
        "btnShearY": "Shear Y",
        "btnRotate90": "Rotate 90¬∞",
        "btnRotate180": "Rotate 180¬∞",
        "secActions": "Actions",
        "btnToggleOriginal": "Toggle Original",
        "btnToggleGrid": "Toggle Grid",
        "btnResetAll": "Reset All",
        "secCustomPoints": "Custom Points",
        "lblPoints": "Points (x,y pairs):",
        "btnApplyPoints": "Apply Points",
        
        // Drawing
        "secDrawingTools": "Drawing Tools",
        "secTool": "Tool",
        "btnPen": "‚úèÔ∏è Pen",
        "btnEraser": "üßπ Eraser",
        "btnLine": "üìè Line",
        "btnRect": "‚ñ≠ Rectangle",
        "btnCircleTool": "‚≠ï Circle",
        "btnText": "üìù Text",
        "secColor": "Color",
        "secBrushSize": "Brush Size:",
        "secBackground": "Background",
        "btnWhite": "‚¨ú White",
        "btnBlack": "‚¨õ Black",
        "btnTransparent": "üî≤ Transparent",
        "secGrid": "Grid",
        "btnToggleGridDraw": "üìê Toggle Grid",
        "lblGridSize": "Grid Size:",
        "btnClearCanvas": "üóëÔ∏è Clear Canvas",
        "btnUndoDraw": "‚Ü©Ô∏è Undo",
        "btnSavePng": "üíæ Save PNG",
        
        // JS Strings
        "msgEnterText": "Enter text:",
        "msgClearCanvas": "Clear the entire canvas?",
        "msgInvalidFunction": "Error: Invalid function",
        "lblSize": "Size",
        "lblWidth": "Width",
        "lblHeight": "Height",
        "lblDepth": "Depth",
        "lblBaseSize": "Base Size",
        "lblRadius": "Radius",
        "msgLatexCopied": "LaTeX copied to clipboard:\n\n",
        "msgExprEmpty": "Expression is empty",
        "msgDisplayNotFound": "Display element not found",
        "msgExprEmptyCreate": "Expression is empty. Please create an expression first.",
        "msgExportFailed": "Failed to export image. Please try again.",
        "msgNoLatexMeta": "No LaTeX metadata found in this image. Please select a JPEG exported from this application.",
        "msgImportFailed": "Failed to import from JPEG: ",
        "lblLatex": "LaTeX",
        "lblData": "Data"
    },
    hy: {
        // Header & Tabs
        "appTitle": "’Ñ’°’©’•’¥’°’ø’´’Ø’°’Ø’°’∂ ‘Ω’¥’¢’°’£÷Ä’´’π",
        "tabEditor": "‘Ω’¥’¢’°’£÷Ä’´’π",
        "tabGraphing": "‘≥÷Ä’°÷Ü’´’Ø’∂’•÷Ä ÷á 3D",
        "tabTransformations": "2D ’Å÷á’°÷É’∏’≠’∏÷Ç’©’µ’∏÷Ç’∂’∂’•÷Ä",
        "tabDrawing": "‘±’¶’°’ø ’Ü’Ø’°÷Ä’π’∏÷Ç’©’µ’∏÷Ç’∂",
        
        // Controls
        "clear": "’Ñ’°÷Ñ÷Ä’•’¨",
        "undo": "’Ä’•’ø’°÷Ä’Ø’•’¨",
        "exportLatex": "‘±÷Ä’ø’°’∞’°’∂’•’¨ LaTeX",
        "exportJpeg": "‘±÷Ä’ø’°’∞’°’∂’•’¨ JPEG",
        "importJpeg": "’Ü’•÷Ä’¥’∏÷Ç’Æ’•’¨ JPEG-’´÷Å",
        "evaluate": "’Ä’°’∑’æ’•’¨",
        "result": "‘±÷Ä’§’µ’∏÷Ç’∂÷Ñ’ù ",
        "msgEvalError": "’Ä’°’∑’æ’°÷Ä’Ø’´ ’ç’≠’°’¨’ù ",
        
        // Editor
        "secNumbers": "‘π’æ’•÷Ä",
        "secSpecialFunctions": "’Ä’°’ø’∏÷Ç’Ø ’ñ’∏÷Ç’∂’Ø÷Å’´’°’∂’•÷Ä",
        "secLatinLetters": "‘º’°’ø’´’∂’°’Ø’°’∂ ’è’°’º’•÷Ä",
        "secGreekSymbols": "’Ä’∏÷Ç’∂’°’Ø’°’∂ ÷á ’ç’´’¥’æ’∏’¨’∂’•÷Ä",
        "secNavigation": "’Ü’°’æ’°÷Ä’Ø’∏÷Ç’©’µ’∏÷Ç’∂",
        "btnShowAll": "’ë’∏÷Ç÷Å’°’§÷Ä’•’¨ ‘≤’∏’¨’∏÷Ä’®",
        "btnShowLess": "‘π’°÷Ñ÷Å’∂’•’¨",
        "navHelp1": "’ï’£’ø’°’£’∏÷Ä’Æ’•÷Ñ ’Ω’¨’°÷Ñ’∂’•÷Ä’® ’ø’°÷Ä÷Ä’•÷Ä’´ ’¥’´’ª÷á ’∂’°’æ’°÷Ä’Ø’•’¨’∏÷Ç ’∞’°’¥’°÷Ä",
        "navHelp2": "Tab / Shift+Tab ’•’∂’©’°’ø’°÷Ä÷Ä’•÷Ä’´ ’¥’´’ª÷á ’°’∂÷Å’∂’•’¨’∏÷Ç ’∞’°’¥’°÷Ä",
        "navHelp3": "Backspace’ù ’ª’∂’ª’•’¨’∏÷Ç ’∞’°’¥’°÷Ä ‚Ä¢ Esc’ù ’•’∂’©’°’ø’°÷Ä÷Ä’´÷Å ’§’∏÷Ç÷Ä’Ω ’£’°’¨’∏÷Ç ’∞’°’¥’°÷Ä",
        "navHelp4": "Enter’ù ’¢’°’¶’¥’°’ø’∏’≤ ’°÷Ä’ø’°’∞’°’µ’ø’∏÷Ç’©’µ’∏÷Ç’∂’∂’•÷Ä’´ ’∞’°’¥’°÷Ä",
        
        // Graphing
        "secChartType": "‘¥’´’°’£÷Ä’°’¥’´ ’è’•’Ω’°’Ø",
        "btnFunctionGraph": "’ñ’∏÷Ç’∂’Ø÷Å’´’°’µ’´ ‘≥÷Ä’°÷Ü’´’Ø",
        "btnBarChart": "’ç’µ’∏÷Ç’∂’°’Ø’°’µ’´’∂",
        "btnLineChart": "‘≥’Æ’°’µ’´’∂",
        "btnPieChart": "’á÷Ä’ª’°’∂’°’±÷á",
        "sec3DShapes": "3D ’ä’°’ø’Ø’•÷Ä’∂’•÷Ä",
        "sec3DControls": "3D ‘ø’°’º’°’æ’°÷Ä’∏÷Ç’¥",
        "btnPyramid": "‘≤’∏÷Ç÷Ä’£",
        "btnCube": "‘Ω’∏÷Ä’°’∂’°÷Ä’§",
        "btnCylinder": "‘≥’¨’°’∂",
        "btnCuboid": "’à÷Ç’≤’≤’°’∂’Ø’µ’∏÷Ç’∂’°’∂’´’Ω’ø",
        "btnSphere": "‘≥’∏÷Ç’∂’§",
        "btnCone": "‘ø’∏’∂",
        "secFunctionInput": "’ñ’∏÷Ç’∂’Ø÷Å’´’°’µ’´ ’Ñ’∏÷Ç’ø÷Ñ’°’£÷Ä’∏÷Ç’¥",
        "lblXMin": "X ’Ñ’´’∂:",
        "lblXMax": "X ’Ñ’°÷Ñ’Ω:",
        "lblYMin": "Y ’Ñ’´’∂:",
        "lblYMax": "Y ’Ñ’°÷Ñ’Ω:",
        "btnPlotGraph": "‘ø’°’º’∏÷Ç÷Å’•’¨ ‘≥÷Ä’°÷Ü’´’Ø’®",
        "secChartData": "‘¥’´’°’£÷Ä’°’¥’´ ’è’æ’µ’°’¨’∂’•÷Ä",
        "lblLabels": "’ä’´’ø’°’Ø’∂’•÷Ä (’Ω’ø’∏÷Ä’°’Ø’•’ø’∏’æ):",
        "lblValues": "‘±÷Ä’™’•÷Ñ’∂’•÷Ä (’Ω’ø’∏÷Ä’°’Ø’•’ø’∏’æ):",
        "btnPlotChart": "‘ø’°’º’∏÷Ç÷Å’•’¨ ‘¥’´’°’£÷Ä’°’¥’®",
        "secShapeParams": "’ä’°’ø’Ø’•÷Ä’´ ’ä’°÷Ä’°’¥’•’ø÷Ä’•÷Ä",
        "btnRenderShape": "’ä’°’ø’Ø’•÷Ä’•’¨",
        "lblRotationX": "’ä’ø’∏÷Ç’µ’ø X:",
        "lblRotationY": "’ä’ø’∏÷Ç’µ’ø Y:",
        "lblRotationZ": "’ä’ø’∏÷Ç’µ’ø Z:",
        "lblZoom": "’Ñ’°’Ω’∑’ø’°’¢:",
        "btnResetView": "’é’•÷Ä’°’Ø’°’∂’£’∂’•’¨ ’è’•’Ω÷Ñ’®",
        
        // Transformations
        "sec2DShape": "2D ’ä’°’ø’Ø’•÷Ä",
        "btnTriangle": "‘µ’º’°’∂’Ø’µ’∏÷Ç’∂",
        "btnSquare": "’î’°’º’°’Ø’∏÷Ç’Ω’´",
        "btnRectangle": "’à÷Ç’≤’≤’°’∂’Ø’µ’∏÷Ç’∂",
        "btnCircle": "’á÷Ä’ª’°’∂",
        "btnPolygon": "‘≤’°’¶’¥’°’∂’Ø’µ’∏÷Ç’∂",
        "btnCustomPoints": "‘±’µ’¨ ‘ø’•’ø’•÷Ä",
        "secTransformations": "’Å÷á’°÷É’∏’≠’∏÷Ç’©’µ’∏÷Ç’∂’∂’•÷Ä",
        "lblTransX": "’è’•’≤’°÷É’∏’≠’∏÷Ç’©’µ’∏÷Ç’∂ X:",
        "lblTransY": "’è’•’≤’°÷É’∏’≠’∏÷Ç’©’µ’∏÷Ç’∂ Y:",
        "lblRotation": "’ä’ø’∏÷Ç’µ’ø:",
        "lblScale": "’Ñ’°’Ω’∑’ø’°’¢:",
        "lblRotCenter": "’ä’ø’ø’¥’°’∂ ‘ø’•’∂’ø÷Ä’∏’∂",
        "lblCenterX": "‘ø’•’∂’ø÷Ä’∏’∂ X:",
        "lblCenterY": "‘ø’•’∂’ø÷Ä’∏’∂ Y:",
        "btnCenterAtShape": "‘ø’•’∂’ø÷Ä’∏’∂’® ’ä’°’ø’Ø’•÷Ä’´ ’é÷Ä’°",
        "secReflections": "’Ä’°’¥’°’π’°÷É’∏÷Ç’©’µ’∏÷Ç’∂’∂’•÷Ä",
        "btnReflectX": "’Ä’°’¥’°’π’°÷É X-’´ ’∂’Ø’°’ø’¥’°’¥’¢",
        "btnReflectY": "’Ä’°’¥’°’π’°÷É Y-’´ ’∂’Ø’°’ø’¥’°’¥’¢",
        "btnReflectOrigin": "’Ä’°’¥’°’π’°÷É O-’´ ’∂’Ø’°’ø’¥’°’¥’¢",
        "btnReflectYeqX": "’Ä’°’¥’°’π’°÷É y=x-’´ ’∂’Ø’°’ø’¥’°’¥’¢",
        "secSpecialTrans": "’Ä’°’ø’∏÷Ç’Ø ’Å÷á’°÷É’∏’≠’∏÷Ç’©’µ’∏÷Ç’∂’∂’•÷Ä",
        "btnShearX": "’ç’°’∞÷Ñ X",
        "btnShearY": "’ç’°’∞÷Ñ Y",
        "btnRotate90": "’ä’ø’ø’•’¨ 90¬∞",
        "btnRotate180": "’ä’ø’ø’•’¨ 180¬∞",
        "secActions": "‘≥’∏÷Ä’Æ’∏’≤’∏÷Ç’©’µ’∏÷Ç’∂’∂’•÷Ä",
        "btnToggleOriginal": "’ë’∏÷Ç÷Å’°’§÷Ä’•’¨ ‘≤’∂÷Ö÷Ä’´’∂’°’Ø’®",
        "btnToggleGrid": "’ë’∏÷Ç÷Å’°’§÷Ä’•’¨ ’ë’°’∂÷Å’®",
        "btnResetAll": "’é’•÷Ä’°’Ø’°’∂’£’∂’•’¨ ‘≤’∏’¨’∏÷Ä’®",
        "secCustomPoints": "‘±’µ’¨ ‘ø’•’ø’•÷Ä",
        "lblPoints": "‘ø’•’ø’•÷Ä (x,y):",
        "btnApplyPoints": "‘ø’´÷Ä’°’º’•’¨",
        
        // Drawing
        "secDrawingTools": "’Ü’Ø’°÷Ä’π’°’Ø’°’∂ ‘≥’∏÷Ä’Æ’´÷Ñ’∂’•÷Ä",
        "secTool": "‘≥’∏÷Ä’Æ’´÷Ñ",
        "btnPen": "‚úèÔ∏è ‘≥÷Ä’´’π",
        "btnEraser": "üßπ ’å’•’ø’´’∂",
        "btnLine": "üìè ‘≥’´’Æ",
        "btnRect": "‚ñ≠ ’à÷Ç’≤’≤’°’∂’Ø’µ’∏÷Ç’∂",
        "btnCircleTool": "‚≠ï ’á÷Ä’ª’°’∂",
        "btnText": "üìù ’è’•÷Ñ’Ω’ø",
        "secColor": "‘≥’∏÷Ç’µ’∂",
        "secBrushSize": "’é÷Ä’±’∂’´ ’â’°÷É:",
        "secBackground": "’ñ’∏’∂",
        "btnWhite": "‚¨ú ’ç’∫’´’ø’°’Ø",
        "btnBlack": "‚¨õ ’ç÷á",
        "btnTransparent": "üî≤ ‘π’°÷É’°’∂÷Å’´’Ø",
        "secGrid": "’ë’°’∂÷Å",
        "btnToggleGridDraw": "üìê ’ë’∏÷Ç÷Å’°’§÷Ä’•’¨ ’ë’°’∂÷Å’®",
        "lblGridSize": "’ë’°’∂÷Å’´ ’â’°÷É:",
        "btnClearCanvas": "üóëÔ∏è ’Ñ’°÷Ñ÷Ä’•’¨ ‘ø’ø’°’æ’®",
        "btnUndoDraw": "‚Ü©Ô∏è ’Ä’•’ø’°÷Ä’Ø’•’¨",
        "btnSavePng": "üíæ ’ä’°’∞’∫’°’∂’•’¨ PNG",
        
        // JS Strings
        "msgEnterText": "’Ñ’∏÷Ç’ø÷Ñ’°’£÷Ä’•÷Ñ ’ø’•÷Ñ’Ω’ø’®:",
        "msgClearCanvas": "’Ñ’°÷Ñ÷Ä’•’û’¨ ’°’¥’¢’∏’≤’ª ’Ø’ø’°’æ’®:",
        "msgInvalidFunction": "’ç’≠’°’¨’ù ‘±’∂’æ’°’æ’•÷Ä ÷Ü’∏÷Ç’∂’Ø÷Å’´’°",
        "lblSize": "’â’°÷É",
        "lblWidth": "‘º’°’µ’∂’∏÷Ç’©’µ’∏÷Ç’∂",
        "lblHeight": "‘≤’°÷Ä’±÷Ä’∏÷Ç’©’µ’∏÷Ç’∂",
        "lblDepth": "‘Ω’∏÷Ä’∏÷Ç’©’µ’∏÷Ç’∂",
        "lblBaseSize": "’Ä’´’¥÷Ñ’´ ’â’°÷É",
        "lblRadius": "’á’°’º’°’æ’´’≤",
        "msgLatexCopied": "LaTeX-’® ’∫’°’ø’≥’•’∂’æ’°’Æ ’ß:\n\n",
        "msgExprEmpty": "‘±÷Ä’ø’°’∞’°’µ’ø’∏÷Ç’©’µ’∏÷Ç’∂’® ’§’°’ø’°÷Ä’Ø ’ß",
        "msgDisplayNotFound": "’ë’∏÷Ç÷Å’°’§÷Ä’¥’°’∂ ’ø’°÷Ä÷Ä’® ’π’´ ’£’ø’∂’æ’•’¨",
        "msgExprEmptyCreate": "‘±÷Ä’ø’°’∞’°’µ’ø’∏÷Ç’©’µ’∏÷Ç’∂’® ’§’°’ø’°÷Ä’Ø ’ß: ‘Ω’∂’§÷Ä’∏÷Ç’¥ ’•’∂÷Ñ ’Ω’ø’•’≤’Æ’•’¨ ’°÷Ä’ø’°’∞’°’µ’ø’∏÷Ç’©’µ’∏÷Ç’∂:",
        "msgExportFailed": "’â’∞’°’ª’∏’≤’æ’•÷Å ’°÷Ä’ø’°’∞’°’∂’•’¨ ’∫’°’ø’Ø’•÷Ä’®:",
        "msgNoLatexMeta": "‘±’µ’Ω ’∫’°’ø’Ø’•÷Ä’∏÷Ç’¥ LaTeX ’¥’•’ø’°’ø’æ’µ’°’¨’∂’•÷Ä ’π’•’∂ ’£’ø’∂’æ’•’¨:",
        "msgImportFailed": "’â’∞’°’ª’∏’≤’æ’•÷Å ’∂’•÷Ä’¥’∏÷Ç’Æ’•’¨ JPEG-’´÷Å: ",
        "lblLatex": "LaTeX",
        "lblData": "’è’æ’µ’°’¨’∂’•÷Ä"
    }
};

// Math Expression Tree Structure
class MathExpression {
    constructor() {
        this.elements = [];
        this.cursorPosition = 0;
        this.history = [];
        this.maxHistory = 50;
    }

    // Add element at cursor position
    addElement(element) {
        this.saveState();
        this.elements.splice(this.cursorPosition, 0, element);
        this.cursorPosition++;
    }

    // Remove element at position
    removeElement(position) {
        if (position >= 0 && position < this.elements.length) {
            this.saveState();
            this.elements.splice(position, 1);
            if (this.cursorPosition > position) {
                this.cursorPosition--;
            }
        }
    }

    // Remove element before cursor (backspace)
    backspace() {
        if (this.cursorPosition > 0) {
            this.removeElement(this.cursorPosition - 1);
        }
    }

    // Move cursor
    moveCursor(direction) {
        if (direction === 'left' && this.cursorPosition > 0) {
            this.cursorPosition--;
            return true;
        } else if (direction === 'right' && this.cursorPosition < this.elements.length) {
            this.cursorPosition++;
            return true;
        }
        return false;
    }

    // Save state for undo
    saveState() {
        const state = {
            elements: JSON.parse(JSON.stringify(this.elements)),
            cursorPosition: this.cursorPosition
        };
        this.history.push(state);
        if (this.history.length > this.maxHistory) {
            this.history.shift();
        }
    }

    // Undo last action
    undo() {
        if (this.history.length > 0) {
            const state = this.history.pop();
            this.elements = state.elements;
            this.cursorPosition = state.cursorPosition;
            return true;
        }
        return false;
    }

    // Clear all
    clear() {
        this.saveState();
        this.elements = [];
        this.cursorPosition = 0;
    }

    // Export to LaTeX
    toLatex() {
        return this.elements.map(el => this.elementToLatex(el)).join(' ');
    }

    // Export to Math String for evaluation
    toMathString() {
        return this.elements.map(el => this.elementToMathString(el)).join(' ');
    }

    elementToMathString(element) {
        switch (element.type) {
            case 'number':
                return element.value;
            
            case 'symbol':
                const symbolMap = {
                    'œÄ': 'Math.PI',
                    'e': 'Math.E',
                    'Œ∏': 'theta',
                    'Œ±': 'alpha',
                    'Œ≤': 'beta',
                    'Œ≥': 'gamma',
                    '¬±': '' // Cannot evaluate plus-minus
                };
                return symbolMap[element.value] || element.value;
            
            case 'operator':
                const opMap = {
                    '√ó': '*',
                    '√∑': '/',
                    '‚àí': '-',
                    '=': '='
                };
                return opMap[element.value] || element.value;
            
            case 'fraction':
                const num = element.numerator.map(el => this.elementToMathString(el)).join('');
                const den = element.denominator.map(el => this.elementToMathString(el)).join('');
                return `(${num || 0})/(${den || 1})`;
            
            case 'power':
                const base = element.base.map(el => this.elementToMathString(el)).join('');
                const exp = element.exponent.map(el => this.elementToMathString(el)).join('');
                return `(${base || 0})**(${exp || 1})`;
            
            case 'subscript':
                // JS evaluation doesn't support subscripts
                return element.base.map(el => this.elementToMathString(el)).join('');
            
            case 'sqrt':
                const content = element.content.map(el => this.elementToMathString(el)).join('');
                return `Math.sqrt(${content || 0})`;
            
            case 'function':
                const funcMap = {
                    'sin': 'Math.sin',
                    'cos': 'Math.cos',
                    'tan': 'Math.tan',
                    'log': 'Math.log10',
                    'ln': 'Math.log',
                    'abs': 'Math.abs',
                    'sum': 'sum', // Not supported in pure JS without implementation
                    'product': 'product',
                    'limit': 'limit',
                    'integral': 'integral'
                };
                return funcMap[element.value] || element.value;
            
            case 'parens':
                const parenContent = element.content.map(el => this.elementToMathString(el)).join('');
                return `(${parenContent})`;
            
            case 'linebreak':
                return ' ';
            
            default:
                return element.value || '';
        }
    }

    elementToLatex(element) {
        switch (element.type) {
            case 'number':
                return element.value;
            
            case 'symbol':
                // Convert special symbols to LaTeX commands
                if (element.value === '¬±') {
                    return '\\pm';
                }
                return element.value;
            
            case 'operator':
                const opMap = {
                    '*': '\\times',
                    '/': '\\div',
                    '=': '=',
                    '+': '+',
                    '-': '-'
                };
                return opMap[element.value] || element.value;
            
            case 'fraction':
                const num = element.numerator.map(el => this.elementToLatex(el)).join(' ');
                const den = element.denominator.map(el => this.elementToLatex(el)).join(' ');
                return `\\frac{${num}}{${den}}`;
            
            case 'power':
                const base = element.base.map(el => this.elementToLatex(el)).join(' ');
                const exp = element.exponent.map(el => this.elementToLatex(el)).join(' ');
                return `{${base}}^{${exp}}`;
            
            case 'subscript':
                const sub_base = element.base.map(el => this.elementToLatex(el)).join(' ');
                const index = element.index.map(el => this.elementToLatex(el)).join(' ');
                return `{${sub_base}}_{${index}}`;
            
            case 'sqrt':
                const content = element.content.map(el => this.elementToLatex(el)).join(' ');
                return `\\sqrt{${content}}`;
            
            case 'function':
                const funcMap = {
                    'sin': '\\sin',
                    'cos': '\\cos',
                    'tan': '\\tan',
                    'log': '\\log',
                    'ln': '\\ln',
                    'sum': '\\sum',
                    'product': '\\prod',
                    'integral': '\\int',
                    'limit': '\\lim'
                };
                return funcMap[element.value] || element.value;
            
            case 'parens':
                const parenContent = element.content.map(el => this.elementToLatex(el)).join(' ');
                return `\\left(${parenContent}\\right)`;
            
            case 'linebreak':
                return '\\\\';
            
            default:
                return element.value || '';
        }
    }
}

// Element factory functions
class ElementFactory {
    static createNumber(value) {
        return { type: 'number', value: value };
    }

    static createOperator(value) {
        return { type: 'operator', value: value };
    }

    static createSymbol(value) {
        const symbolMap = {
            'pi': 'œÄ',
            'theta': 'Œ∏',
            'alpha': 'Œ±',
            'beta': 'Œ≤',
            'gamma': 'Œ≥',
            'delta': 'Œ¥',
            'epsilon': 'Œµ',
            'lambda': 'Œª',
            'mu': 'Œº',
            'sigma': 'œÉ'
        };
        return { type: 'symbol', value: symbolMap[value] || value };
    }

    static createFraction() {
        return {
            type: 'fraction',
            numerator: [],
            denominator: [],
            activeSection: 'numerator'  // 'numerator' or 'denominator'
        };
    }

    static createPower() {
        return {
            type: 'power',
            base: [],
            exponent: [],
            activeSection: 'base'  // 'base' or 'exponent'
        };
    }

    static createSubscript() {
        return {
            type: 'subscript',
            base: [],
            index: [],
            activeSection: 'base'  // 'base' or 'index'
        };
    }

    static createSqrt() {
        return {
            type: 'sqrt',
            content: []
        };
    }

    static createFunction(name) {
        return {
            type: 'function',
            value: name,
            argument: []
        };
    }

    static createParens() {
        return {
            type: 'parens',
            content: []
        };
    }

    static createLineBreak() {
        return {
            type: 'linebreak'
        };
    }
}

// Navigation context for complex elements
class NavigationContext {
    constructor() {
        this.stack = [];  // Stack of {element, section, position}
        this.currentElement = null;
        this.currentSection = null;
        this.currentPosition = 0;
    }

    // Enter a complex element (fraction, power, etc.)
    enter(element, section = null) {
        this.stack.push({
            element: this.currentElement,
            section: this.currentSection,
            position: this.currentPosition
        });
        
        this.currentElement = element;
        this.currentSection = section || this.getFirstSection(element);
        this.currentPosition = 0;
    }

    // Exit current complex element
    exit() {
        if (this.stack.length > 0) {
            const prev = this.stack.pop();
            this.currentElement = prev.element;
            this.currentSection = prev.section;
            this.currentPosition = prev.position;
            return true;
        }
        this.currentElement = null;
        this.currentSection = null;
        this.currentPosition = 0;
        return false;
    }

    // Navigate to next section in current element
    nextSection() {
        if (!this.currentElement) return false;
        
        const sections = this.getSections(this.currentElement);
        const currentIndex = sections.indexOf(this.currentSection);
        
        if (currentIndex < sections.length - 1) {
            this.currentSection = sections[currentIndex + 1];
            this.currentPosition = 0;
            return true;
        }
        return false;
    }

    // Navigate to previous section in current element
    previousSection() {
        if (!this.currentElement) return false;
        
        const sections = this.getSections(this.currentElement);
        const currentIndex = sections.indexOf(this.currentSection);
        
        if (currentIndex > 0) {
            this.currentSection = sections[currentIndex - 1];
            this.currentPosition = 0;
            return true;
        }
        return false;
    }

    // Get all sections for an element type
    getSections(element) {
        switch (element.type) {
            case 'fraction':
                return ['numerator', 'denominator'];
            case 'power':
                return ['base', 'exponent'];
            case 'subscript':
                return ['base', 'index'];
            case 'sqrt':
            case 'parens':
            case 'function':
                return ['content'];
            default:
                return [];
        }
    }

    // Get first section for an element
    getFirstSection(element) {
        const sections = this.getSections(element);
        return sections.length > 0 ? sections[0] : null;
    }

    // Get current section array
    getCurrentSectionArray() {
        if (!this.currentElement || !this.currentSection) return null;
        
        switch (this.currentElement.type) {
            case 'fraction':
                return this.currentElement[this.currentSection];  // numerator or denominator
            case 'power':
                return this.currentElement[this.currentSection];  // base or exponent
            case 'subscript':
                return this.currentElement[this.currentSection];  // base or index
            case 'sqrt':
                return this.currentElement.content;
            case 'parens':
                return this.currentElement.content;
            case 'function':
                return this.currentElement.argument;
            default:
                return null;
        }
    }

    // Check if we're inside a complex element
    isInsideElement() {
        return this.currentElement !== null;
    }

    // Get depth of nesting
    getDepth() {
        return this.stack.length;
    }

    // Clear context
    clear() {
        this.stack = [];
        this.currentElement = null;
        this.currentSection = null;
        this.currentPosition = 0;
    }
}

// Navigation System for Math Expressions
class NavigationSystem {
    constructor(expression, navContext) {
        this.expression = expression;
        this.navContext = navContext;
    }

    // Get the current active position information
    getActivePosition() {
        if (this.navContext.isInsideElement()) {
            return {
                type: 'section',
                element: this.navContext.currentElement,
                section: this.navContext.currentSection,
                position: this.navContext.currentPosition,
                depth: this.navContext.getDepth()
            };
        } else {
            return {
                type: 'main',
                position: this.expression.cursorPosition,
                depth: 0
            };
        }
    }

    // Navigate to specific element in main expression
    navigateToElement(index) {
        if (index >= 0 && index <= this.expression.elements.length) {
            this.navContext.clear();
            this.expression.cursorPosition = index;
            return true;
        }
        return false;
    }

    // Navigate into a complex element
    navigateInto(elementIndex, section = null) {
        if (elementIndex >= 0 && elementIndex < this.expression.elements.length) {
            const element = this.expression.elements[elementIndex];
            
            if (this.isNavigableElement(element)) {
                this.expression.cursorPosition = elementIndex;
                this.navContext.clear();
                this.navContext.enter(element, section);
                return true;
            }
        }
        return false;
    }

    // Navigate out of current complex element
    navigateOut() {
        if (this.navContext.isInsideElement()) {
            this.navContext.exit();
            return true;
        }
        return false;
    }

    // Check if element can be navigated into
    isNavigableElement(element) {
        return element && (
            element.type === 'fraction' ||
            element.type === 'power' ||
            element.type === 'subscript' ||
            element.type === 'sqrt' ||
            element.type === 'parens' ||
            element.type === 'function'
        );
    }

    // Get all navigable sections of current element
    getNavigableSections() {
        if (!this.navContext.isInsideElement()) {
            return [];
        }
        return this.navContext.getSections(this.navContext.currentElement);
    }

    // Get element at current cursor position
    getCurrentElement() {
        const pos = this.expression.cursorPosition;
        if (pos > 0 && pos <= this.expression.elements.length) {
            return this.expression.elements[pos - 1];
        }
        return null;
    }

    // Get element after cursor
    getNextElement() {
        const pos = this.expression.cursorPosition;
        if (pos < this.expression.elements.length) {
            return this.expression.elements[pos];
        }
        return null;
    }

    // Smart navigation - find next/previous editable position
    findNextPosition() {
        if (this.navContext.isInsideElement()) {
            const sectionArray = this.navContext.getCurrentSectionArray();
            
            // Try to move within current section
            if (sectionArray && this.navContext.currentPosition < sectionArray.length) {
                // Check if next element in section is complex
                const nextEl = sectionArray[this.navContext.currentPosition];
                if (this.isNavigableElement(nextEl)) {
                    return { type: 'enter-nested', element: nextEl };
                } else {
                    this.navContext.currentPosition++;
                    return { type: 'same-section' };
                }
            }
            
            // Try to move to next section
            if (this.navContext.nextSection()) {
                return { type: 'next-section' };
            }
            
            // Exit to parent
            this.navContext.exit();
            return { type: 'exit-parent' };
        } else {
            // Main expression navigation
            if (this.expression.cursorPosition < this.expression.elements.length) {
                const nextEl = this.expression.elements[this.expression.cursorPosition];
                if (this.isNavigableElement(nextEl)) {
                    return { type: 'enter', element: nextEl };
                } else {
                    this.expression.moveCursor('right');
                    return { type: 'move-right' };
                }
            }
            return { type: 'end' };
        }
    }

    findPreviousPosition() {
        if (this.navContext.isInsideElement()) {
            // Try to move within current section
            if (this.navContext.currentPosition > 0) {
                this.navContext.currentPosition--;
                
                const sectionArray = this.navContext.getCurrentSectionArray();
                const prevEl = sectionArray[this.navContext.currentPosition];
                
                if (this.isNavigableElement(prevEl)) {
                    return { type: 'enter-nested-end', element: prevEl };
                }
                return { type: 'same-section' };
            }
            
            // Try to move to previous section
            if (this.navContext.previousSection()) {
                // Move to end of previous section
                const sectionArray = this.navContext.getCurrentSectionArray();
                if (sectionArray) {
                    this.navContext.currentPosition = sectionArray.length;
                }
                return { type: 'previous-section' };
            }
            
            // Exit to parent
            this.navContext.exit();
            return { type: 'exit-parent' };
        } else {
            // Main expression navigation
            if (this.expression.cursorPosition > 0) {
                const prevEl = this.expression.elements[this.expression.cursorPosition - 1];
                if (this.isNavigableElement(prevEl)) {
                    return { type: 'enter-end', element: prevEl };
                } else {
                    this.expression.moveCursor('left');
                    return { type: 'move-left' };
                }
            }
            return { type: 'start' };
        }
    }

    // Get breadcrumb path for current position
    getBreadcrumbs() {
        const breadcrumbs = ['Expression'];
        
        if (this.navContext.isInsideElement()) {
            // Build path from stack
            for (let i = 0; i < this.navContext.stack.length; i++) {
                const item = this.navContext.stack[i];
                if (item.element) {
                    breadcrumbs.push(this.getElementLabel(item.element, item.section));
                }
            }
            
            // Add current element
            if (this.navContext.currentElement) {
                breadcrumbs.push(
                    this.getElementLabel(
                        this.navContext.currentElement,
                        this.navContext.currentSection
                    )
                );
            }
        }
        
        return breadcrumbs;
    }

    // Get human-readable label for element and section
    getElementLabel(element, section) {
        if (!element) return 'Unknown';
        
        const labels = {
            'fraction': {
                'numerator': 'Fraction (Numerator)',
                'denominator': 'Fraction (Denominator)'
            },
            'power': {
                'base': 'Power (Base)',
                'exponent': 'Power (Exponent)'
            },
            'subscript': {
                'base': 'Subscript (Base)',
                'index': 'Subscript (Index)'
            },
            'sqrt': {
                'content': 'Square Root'
            },
            'parens': {
                'content': 'Parentheses'
            },
            'function': {
                'argument': `Function ${element.value || ''}`
            }
        };
        
        if (labels[element.type] && section) {
            return labels[element.type][section] || element.type;
        }
        
        return element.type;
    }

    // Validate navigation state
    isValidState() {
        // Check if navigation context is consistent
        if (this.navContext.isInsideElement()) {
            const sectionArray = this.navContext.getCurrentSectionArray();
            if (!sectionArray) return false;
            
            if (this.navContext.currentPosition < 0 || 
                this.navContext.currentPosition > sectionArray.length) {
                return false;
            }
        }
        
        if (this.expression.cursorPosition < 0 || 
            this.expression.cursorPosition > this.expression.elements.length) {
            return false;
        }
        
        return true;
    }

    // Reset navigation to safe state
    reset() {
        this.navContext.clear();
        this.expression.cursorPosition = this.expression.elements.length;
    }

    // Get statistics about current expression
    getStats() {
        return {
            totalElements: this.expression.elements.length,
            cursorPosition: this.expression.cursorPosition,
            nestingDepth: this.navContext.getDepth(),
            isInsideElement: this.navContext.isInsideElement(),
            currentSection: this.navContext.currentSection,
            historySize: this.expression.history.length
        };
    }
}

// Helper class for visual navigation feedback
class NavigationRenderer {
    constructor(displayElement) {
        this.displayElement = displayElement;
    }

    // Highlight the active section
    highlightActiveSection(section) {
        // Remove all existing highlights
        const highlighted = this.displayElement.querySelectorAll('.active');
        highlighted.forEach(el => el.classList.remove('active'));
        
        // Add highlight to active section
        if (section) {
            const sectionEl = this.displayElement.querySelector(`[data-section="${section}"]`);
            if (sectionEl) {
                sectionEl.classList.add('active');
            }
        }
    }

    // Show cursor at position
    showCursor(position, isInsideElement = false) {
        // Remove all existing cursors
        const cursors = this.displayElement.querySelectorAll('.cursor');
        cursors.forEach(cursor => cursor.classList.remove('active'));
        
        // Find and activate the correct cursor
        if (isInsideElement) {
            // Cursor is inside a complex element section
            const activeSections = this.displayElement.querySelectorAll('.active');
            if (activeSections.length > 0) {
                const sectionEl = activeSections[activeSections.length - 1];
                const cursors = sectionEl.querySelectorAll('.cursor');
                if (cursors[position]) {
                    cursors[position].classList.add('active');
                }
            }
        } else {
            // Cursor is in main expression
            const mainCursors = this.displayElement.querySelectorAll('.expression-display > .cursor');
            if (mainCursors[position]) {
                mainCursors[position].classList.add('active');
            }
        }
    }

    // Update breadcrumb display
    updateBreadcrumbs(breadcrumbs) {
        // This would update a breadcrumb UI element if we had one
        // console.log('Navigation path:', breadcrumbs.join(' > '));
    }
}

// Keyboard Controller
class KeyboardController {
    constructor(expression, navigationContext, renderCallback) {
        this.expression = expression;
        this.navContext = navigationContext;
        this.renderCallback = renderCallback;
        this.keyboardButtons = [];
        this.enabled = true;
    }

    // Enable/disable keyboard event handling
    setEnabled(enabled) {
        this.enabled = enabled;
    }

    // Initialize keyboard event listeners
    init() {
        // Physical keyboard events
        document.addEventListener('keydown', (e) => this.handleKeyDown(e));
        
        // Virtual keyboard buttons
        this.keyboardButtons = document.querySelectorAll('.key-btn');
        this.keyboardButtons.forEach(btn => {
            btn.addEventListener('click', () => this.handleButtonClick(btn));
        });
    }

    // Handle physical keyboard input
    handleKeyDown(e) {
        // Don't capture keyboard events if disabled or if typing in an input field
        if (!this.enabled || e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            return;
        }
        
        // Arrow key navigation
        if (e.key === 'ArrowLeft') {
            e.preventDefault();
            this.handleArrowLeft();
            return;
        }
        
        if (e.key === 'ArrowRight') {
            e.preventDefault();
            this.handleArrowRight();
            return;
        }
        
        if (e.key === 'ArrowUp') {
            e.preventDefault();
            this.handleArrowUp();
            return;
        }
        
        if (e.key === 'ArrowDown') {
            e.preventDefault();
            this.handleArrowDown();
            return;
        }
        
        // Tab navigation between sections
        if (e.key === 'Tab') {
            e.preventDefault();
            if (e.shiftKey) {
                this.navContext.previousSection();
            } else {
                this.navContext.nextSection();
            }
            this.renderCallback();
            return;
        }
        
        // Escape to exit complex element
        if (e.key === 'Escape') {
            e.preventDefault();
            this.navContext.exit();
            this.renderCallback();
            return;
        }
        
        // Backspace
        if (e.key === 'Backspace') {
            e.preventDefault();
            this.handleBackspace();
            return;
        }
        
        // Numbers
        if (e.key >= '0' && e.key <= '9') {
            e.preventDefault();
            this.insertElement(ElementFactory.createNumber(e.key));
            return;
        }
        
        // Decimal point
        if (e.key === '.') {
            e.preventDefault();
            this.insertElement(ElementFactory.createNumber('.'));
            return;
        }
        
        // Operators
        const operatorMap = {
            '+': '+',
            '-': '-',
            '*': '*',
            '/': '/',
            '=': '='
        };
        
        if (operatorMap[e.key]) {
            e.preventDefault();
            this.insertElement(ElementFactory.createOperator(operatorMap[e.key]));
            return;
        }
        
        // Parentheses
        if (e.key === '(') {
            e.preventDefault();
            this.insertElement(ElementFactory.createSymbol('('));
            return;
        }
        
        if (e.key === ')') {
            e.preventDefault();
            this.insertElement(ElementFactory.createSymbol(')'));
            return;
        }
        
        // Enter for line break
        if (e.key === 'Enter') {
            e.preventDefault();
            this.insertElement(ElementFactory.createLineBreak());
            return;
        }
        
        // Letters (for variables)
        if (e.key.length === 1 && e.key.match(/[a-zA-Z]/)) {
            e.preventDefault();
            this.insertElement(ElementFactory.createSymbol(e.key));
            return;
        }
    }

    // Handle virtual keyboard button click
    handleButtonClick(button) {
        const value = button.dataset.value;
        const type = this.getButtonType(button);
        
        switch (type) {
            case 'number':
                this.insertElement(ElementFactory.createNumber(value));
                break;
            
            case 'operator':
                this.insertElement(ElementFactory.createOperator(value));
                break;
            
            case 'symbol':
                this.insertElement(ElementFactory.createSymbol(value));
                break;
            
            case 'function':
                this.handleFunction(value);
                break;
            
            case 'trig':
                this.insertElement(ElementFactory.createFunction(value));
                break;
        }
        
        this.renderCallback();
    }

    // Get button type from classes
    getButtonType(button) {
        if (button.classList.contains('number')) return 'number';
        if (button.classList.contains('operator')) return 'operator';
        if (button.classList.contains('symbol')) return 'symbol';
        if (button.classList.contains('function')) return 'function';
        if (button.classList.contains('trig')) return 'trig';
        return 'unknown';
    }

    // Handle special functions
    handleFunction(funcName) {
        let element;
        
        switch (funcName) {
            case 'fraction':
                element = ElementFactory.createFraction();
                this.insertElement(element);
                
                // Get the position where we just inserted
                if (this.navContext.isInsideElement()) {
                    const sectionArray = this.navContext.getCurrentSectionArray();
                    const insertedPos = this.navContext.currentPosition - 1;
                    if (sectionArray && sectionArray[insertedPos] === element) {
                        this.navContext.enter(element, 'numerator');
                    }
                } else {
                    const insertedPos = this.expression.cursorPosition - 1;
                    if (this.expression.elements[insertedPos] === element) {
                        this.navContext.enter(element, 'numerator');
                    }
                }
                this.renderCallback();
                break;
            
            case 'power':
            case 'superscript':
                // If there is an element immediately before the cursor (or in the current section),
                // reuse it as the base for the power if it's a simple element (number/symbol).
                if (this.navContext.isInsideElement()) {
                    const sectionArray = this.navContext.getCurrentSectionArray();
                    const pos = this.navContext.currentPosition;
                    if (sectionArray && pos > 0) {
                        const baseEl = sectionArray[pos - 1];
                        // Only reuse if it's a number or symbol
                        if (baseEl.type === 'number' || baseEl.type === 'symbol') {
                            // Remove the previous element and wrap it as the base of a new power
                            sectionArray.splice(pos - 1, 1);
                            const powEl = ElementFactory.createPower();
                            powEl.base.push(baseEl);
                            // Insert the new power where the base was
                            sectionArray.splice(pos - 1, 0, powEl);
                            // Enter the power exponent for editing
                            this.navContext.enter(powEl, 'exponent');
                            this.renderCallback();
                            break;
                        }
                    }
                } else {
                    // Not inside a complex element: check expression main array
                    if (this.expression.cursorPosition > 0) {
                        const prevIndex = this.expression.cursorPosition - 1;
                        const baseEl = this.expression.elements[prevIndex];
                        // Only reuse if it's a number or symbol
                        if (baseEl.type === 'number' || baseEl.type === 'symbol') {
                            // Remove previous element and use it as base
                            this.expression.removeElement(prevIndex);
                            const powEl = ElementFactory.createPower();
                            powEl.base.push(baseEl);
                            // Insert power at the cursor (which was adjusted by removeElement)
                            this.insertElement(powEl);
                            // Enter exponent for editing
                            this.navContext.enter(powEl, 'exponent');
                            this.renderCallback();
                            break;
                        }
                    }
                }

                // Fallback: no previous element or not a simple type ‚Äî create an empty power as before
                element = ElementFactory.createPower();
                this.insertElement(element);
                
                // Get the position where we just inserted
                if (this.navContext.isInsideElement()) {
                    const sectionArray = this.navContext.getCurrentSectionArray();
                    const insertedPos = this.navContext.currentPosition - 1;
                    if (sectionArray && sectionArray[insertedPos] === element) {
                        this.navContext.enter(element, 'base');
                    }
                } else {
                    const insertedPos = this.expression.cursorPosition - 1;
                    if (this.expression.elements[insertedPos] === element) {
                        this.navContext.enter(element, 'base');
                    }
                }
                this.renderCallback();
                break;
            
            case 'subscript':
                // If there is an element immediately before the cursor (or in the current section),
                // reuse it as the base for the subscript if it's a simple element (number/symbol).
                if (this.navContext.isInsideElement()) {
                    const sectionArray = this.navContext.getCurrentSectionArray();
                    const pos = this.navContext.currentPosition;
                    if (sectionArray && pos > 0) {
                        const baseEl = sectionArray[pos - 1];
                        // Only reuse if it's a number or symbol
                        if (baseEl.type === 'number' || baseEl.type === 'symbol') {
                            // Remove the previous element and wrap it as the base of a new subscript
                            sectionArray.splice(pos - 1, 1);
                            const subEl = ElementFactory.createSubscript();
                            subEl.base.push(baseEl);
                            // Insert the new subscript where the base was
                            sectionArray.splice(pos - 1, 0, subEl);
                            // Enter the subscript index for editing
                            this.navContext.enter(subEl, 'index');
                            this.renderCallback();
                            break;
                        }
                    }
                } else {
                    // Not inside a complex element: check expression main array
                    if (this.expression.cursorPosition > 0) {
                        const prevIndex = this.expression.cursorPosition - 1;
                        const baseEl = this.expression.elements[prevIndex];
                        // Only reuse if it's a number or symbol
                        if (baseEl.type === 'number' || baseEl.type === 'symbol') {
                            // Remove previous element and use it as base
                            this.expression.removeElement(prevIndex);
                            const subEl = ElementFactory.createSubscript();
                            subEl.base.push(baseEl);
                            // Insert subscript at the cursor (which was adjusted by removeElement)
                            this.insertElement(subEl);
                            // Enter index for editing
                            this.navContext.enter(subEl, 'index');
                            this.renderCallback();
                            break;
                        }
                    }
                }

                // Fallback: no previous element or not a simple type ‚Äî create an empty subscript as before
                element = ElementFactory.createSubscript();
                this.insertElement(element);
                
                // Get the position where we just inserted
                if (this.navContext.isInsideElement()) {
                    const sectionArray = this.navContext.getCurrentSectionArray();
                    const insertedPos = this.navContext.currentPosition - 1;
                    if (sectionArray && sectionArray[insertedPos] === element) {
                        this.navContext.enter(element, 'base');
                    }
                } else {
                    const insertedPos = this.expression.cursorPosition - 1;
                    if (this.expression.elements[insertedPos] === element) {
                        this.navContext.enter(element, 'base');
                    }
                }
                this.renderCallback();
                break;
            
            case 'sqrt':
                element = ElementFactory.createSqrt();
                this.insertElement(element);
                
                // Get the position where we just inserted
                if (this.navContext.isInsideElement()) {
                    const sectionArray = this.navContext.getCurrentSectionArray();
                    const insertedPos = this.navContext.currentPosition - 1;
                    if (sectionArray && sectionArray[insertedPos] === element) {
                        this.navContext.enter(element, 'content');
                    }
                } else {
                    const insertedPos = this.expression.cursorPosition - 1;
                    if (this.expression.elements[insertedPos] === element) {
                        this.navContext.enter(element, 'content');
                    }
                }
                this.renderCallback();
                break;
            
            case 'sin':
            case 'cos':
            case 'tan':
            case 'log':
            case 'ln':
                element = ElementFactory.createFunction(funcName);
                this.insertElement(element);
                break;
            
            case 'integral':
                this.insertElement(ElementFactory.createSymbol('‚à´'));
                break;
            
            case 'sum':
                this.insertElement(ElementFactory.createSymbol('Œ£'));
                break;
            
            case 'product':
                this.insertElement(ElementFactory.createSymbol('Œ†'));
                break;
            
            case 'limit':
                element = ElementFactory.createFunction('lim');
                this.insertElement(element);
                break;
            
            case 'derivative':
                this.insertElement(ElementFactory.createSymbol('d'));
                this.insertElement(ElementFactory.createOperator('/'));
                this.insertElement(ElementFactory.createSymbol('dx'));
                break;
            
            case 'abs':
                this.insertElement(ElementFactory.createSymbol('|'));
                break;
            
            default:
                console.warn('Unknown function:', funcName);
        }
    }

    // Insert element at current position
    insertElement(element) {
        if (this.navContext.isInsideElement()) {
            // Insert into current section of complex element
            const sectionArray = this.navContext.getCurrentSectionArray();
            if (sectionArray) {
                sectionArray.splice(this.navContext.currentPosition, 0, element);
                this.navContext.currentPosition++;
            }
        } else {
            // Insert into main expression
            this.expression.addElement(element);
        }
        // Render after simple insertions
        if (!this.isComplexElement(element)) {
            this.renderCallback();
        }
    }

    // Handle backspace
    handleBackspace() {
        if (this.navContext.isInsideElement()) {
            const sectionArray = this.navContext.getCurrentSectionArray();
            if (sectionArray && this.navContext.currentPosition > 0) {
                sectionArray.splice(this.navContext.currentPosition - 1, 1);
                this.navContext.currentPosition--;
            } else if (this.navContext.currentPosition === 0) {
                // Try to move to previous section
                if (!this.navContext.previousSection()) {
                    // Exit the complex element
                    this.navContext.exit();
                }
            }
        } else {
            this.expression.backspace();
        }
        this.renderCallback();
    }

    // Arrow key handlers
    handleArrowLeft() {
        if (this.navContext.isInsideElement()) {
            const sectionArray = this.navContext.getCurrentSectionArray();
            
            if (this.navContext.currentPosition > 0) {
                // Check if we're at a complex element within the section
                const prevElement = sectionArray[this.navContext.currentPosition - 1];
                if (this.isComplexElement(prevElement)) {
                    this.navContext.currentPosition--;
                    this.enterElementAtEnd(prevElement);
                } else {
                    this.navContext.currentPosition--;
                }
            } else {
                // At the start of current section, try moving to previous section
                if (!this.navContext.previousSection()) {
                    // Exit element and move cursor left
                    this.navContext.exit();
                    if (!this.navContext.isInsideElement()) {
                        this.expression.moveCursor('left');
                    }
                } else {
                    // Moved to previous section, go to its end
                    const prevSectionArray = this.navContext.getCurrentSectionArray();
                    if (prevSectionArray) {
                        this.navContext.currentPosition = prevSectionArray.length;
                    }
                }
            }
        } else {
            // Check if cursor is on a complex element
            const pos = this.expression.cursorPosition;
            if (pos > 0) {
                const prevElement = this.expression.elements[pos - 1];
                if (this.isComplexElement(prevElement)) {
                    // Enter the element at its last section
                    this.expression.cursorPosition--;
                    this.enterElementAtEnd(prevElement);
                } else {
                    this.expression.moveCursor('left');
                }
            }
        }
        this.renderCallback();
    }

    handleArrowRight() {
        if (this.navContext.isInsideElement()) {
            const sectionArray = this.navContext.getCurrentSectionArray();
            
            if (sectionArray && this.navContext.currentPosition < sectionArray.length) {
                // Check if we're before a complex element within the section
                const nextElement = sectionArray[this.navContext.currentPosition];
                if (this.isComplexElement(nextElement)) {
                    this.navContext.currentPosition++;
                    this.enterElementAtStart(nextElement);
                } else {
                    this.navContext.currentPosition++;
                }
            } else {
                // At the end of current section, try moving to next section
                if (!this.navContext.nextSection()) {
                    // Exit element and move cursor right
                    this.navContext.exit();
                    if (!this.navContext.isInsideElement()) {
                        this.expression.moveCursor('right');
                    }
                } else {
                    // Moved to next section, go to its start
                    this.navContext.currentPosition = 0;
                }
            }
        } else {
            // Check if cursor is before a complex element
            const pos = this.expression.cursorPosition;
            if (pos < this.expression.elements.length) {
                const nextElement = this.expression.elements[pos];
                if (this.isComplexElement(nextElement)) {
                    // Enter the element at its first section
                    this.expression.cursorPosition++;
                    this.enterElementAtStart(nextElement);
                } else {
                    this.expression.moveCursor('right');
                }
            }
        }
        this.renderCallback();
    }

    handleArrowUp() {
        // Move to previous section (up in fraction, etc.)
        if (this.navContext.isInsideElement()) {
            this.navContext.previousSection();
            this.renderCallback();
        }
    }

    handleArrowDown() {
        // Move to next section (down in fraction, etc.)
        if (this.navContext.isInsideElement()) {
            this.navContext.nextSection();
            this.renderCallback();
        }
    }

    // Check if element is complex (has sub-sections)
    isComplexElement(element) {
        return element && (
            element.type === 'fraction' ||
            element.type === 'power' ||
            element.type === 'subscript' ||
            element.type === 'sqrt' ||
            element.type === 'parens'
        );
    }

    // Enter complex element at first section
    enterElementAtStart(element) {
        const firstSection = this.navContext.getFirstSection(element);
        this.navContext.enter(element, firstSection);
        this.navContext.currentPosition = 0;
        this.renderCallback();
    }

    // Enter complex element at last section
    enterElementAtEnd(element) {
        const sections = this.navContext.getSections(element);
        const lastSection = sections[sections.length - 1];
        this.navContext.enter(element, lastSection);
        
        // Set position to end of section
        const sectionArray = this.navContext.getCurrentSectionArray();
        if (sectionArray) {
            this.navContext.currentPosition = sectionArray.length;
        }
        this.renderCallback();
    }
}

// Graphing and 3D Shape Rendering Module

class GraphingController {
    constructor() {
        this.canvas = null;
        this.ctx = null;
        this.chart = null;
        this.currentMode = 'function'; // function, bar, line, pie, shape
        this.currentShape = null;
        
        // 3D transformation properties
        this.rotation = { x: 30, y: 45, z: 0 }; // degrees
        this.zoom = 1.0;
        this.shapeParams = {};
    }

    init(canvasId) {
        this.canvas = document.getElementById(canvasId);
        if (!this.canvas) {
            console.error('Canvas not found');
            return;
        }
        this.ctx = this.canvas.getContext('2d');
        this.resizeCanvas();
        
        // Add resize listener
        window.addEventListener('resize', () => this.resizeCanvas());
    }

    resizeCanvas() {
        const container = this.canvas.parentElement;
        const rect = container.getBoundingClientRect();
        this.canvas.width = rect.width - 40;
        this.canvas.height = rect.height - 40;
    }

    clear() {
        if (this.chart) {
            this.chart.destroy();
            this.chart = null;
        }
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }

    // Plot mathematical function
    plotFunction(funcStr, xMin, xMax, yMin, yMax) {
        this.clear();
        this.currentMode = 'function';

        try {
            // Parse function string (simple parser)
            const func = this.parseFunction(funcStr);
            
            const width = this.canvas.width;
            const height = this.canvas.height;
            const padding = 40;
            
            // Calculate scales
            const xRange = xMax - xMin;
            const yRange = yMax - yMin;
            const xScale = (width - 2 * padding) / xRange;
            const yScale = (height - 2 * padding) / yRange;
            
            // Draw axes
            this.ctx.strokeStyle = '#333';
            this.ctx.lineWidth = 2;
            
            // X-axis
            const yZero = height - padding - (0 - yMin) * yScale;
            this.ctx.beginPath();
            this.ctx.moveTo(padding, yZero);
            this.ctx.lineTo(width - padding, yZero);
            this.ctx.stroke();
            
            // Y-axis
            const xZero = padding + (0 - xMin) * xScale;
            this.ctx.beginPath();
            this.ctx.moveTo(xZero, padding);
            this.ctx.lineTo(xZero, height - padding);
            this.ctx.stroke();
            
            // Draw grid
            this.ctx.strokeStyle = '#e0e0e0';
            this.ctx.lineWidth = 1;
            
            // Vertical grid lines
            for (let x = Math.ceil(xMin); x <= Math.floor(xMax); x++) {
                const canvasX = padding + (x - xMin) * xScale;
                this.ctx.beginPath();
                this.ctx.moveTo(canvasX, padding);
                this.ctx.lineTo(canvasX, height - padding);
                this.ctx.stroke();
                
                // Label
                this.ctx.fillStyle = '#666';
                this.ctx.font = '12px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(x.toString(), canvasX, yZero + 20);
            }
            
            // Horizontal grid lines
            for (let y = Math.ceil(yMin); y <= Math.floor(yMax); y++) {
                const canvasY = height - padding - (y - yMin) * yScale;
                this.ctx.beginPath();
                this.ctx.moveTo(padding, canvasY);
                this.ctx.lineTo(width - padding, canvasY);
                this.ctx.stroke();
                
                // Label
                if (y !== 0) {
                    this.ctx.fillStyle = '#666';
                    this.ctx.font = '12px Arial';
                    this.ctx.textAlign = 'right';
                    this.ctx.fillText(y.toString(), xZero - 10, canvasY + 4);
                }
            }
            
            // Plot function
            this.ctx.strokeStyle = '#667eea';
            this.ctx.lineWidth = 3;
            this.ctx.beginPath();
            
            let firstPoint = true;
            const step = xRange / (width - 2 * padding);
            
            for (let x = xMin; x <= xMax; x += step) {
                try {
                    const y = func(x);
                    
                    if (isNaN(y) || !isFinite(y)) continue;
                    if (y < yMin || y > yMax) continue;
                    
                    const canvasX = padding + (x - xMin) * xScale;
                    const canvasY = height - padding - (y - yMin) * yScale;
                    
                    if (firstPoint) {
                        this.ctx.moveTo(canvasX, canvasY);
                        firstPoint = false;
                    } else {
                        this.ctx.lineTo(canvasX, canvasY);
                    }
                } catch (e) {
                    // Skip invalid points
                }
            }
            
            this.ctx.stroke();
            
            // Draw axis labels
            this.ctx.fillStyle = '#333';
            this.ctx.font = 'bold 14px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.fillText('x', width - padding + 20, yZero);
            this.ctx.fillText('y', xZero, padding - 20);
            
        } catch (error) {
            console.error('Error plotting function:', error);
            this.ctx.fillStyle = '#d32f2f';
            this.ctx.font = '16px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.fillText(window.t('msgInvalidFunction'), this.canvas.width / 2, this.canvas.height / 2);
        }
    }

    // Simple function parser
    parseFunction(funcStr) {
        // Replace common mathematical notation
        let code = funcStr
            .replace(/\^/g, '**')
            .replace(/œÄ/g, 'Math.PI')
            .replace(/pi/g, 'Math.PI')
            .replace(/e(?!\w)/g, 'Math.E')
            .replace(/sin/g, 'Math.sin')
            .replace(/cos/g, 'Math.cos')
            .replace(/tan/g, 'Math.tan')
            .replace(/sqrt/g, 'Math.sqrt')
            .replace(/abs/g, 'Math.abs')
            .replace(/log/g, 'Math.log10')
            .replace(/ln/g, 'Math.log');
        
        // Create function
        return new Function('x', `return ${code};`);
    }

    // Plot chart using Chart.js
    plotChart(type, labels, values) {
        this.clear();
        this.currentMode = type;

        const colors = [
            '#667eea', '#764ba2', '#f093fb', '#4facfe',
            '#43e97b', '#fa709a', '#feca57', '#48dbfb'
        ];
        
        // Register datalabels plugin only for pie charts
        const plugins = type === 'pie' ? [ChartDataLabels] : [];

        const config = {
            type: type === 'bar' ? 'bar' : type === 'line' ? 'line' : 'pie',
            data: {
                labels: labels,
                datasets: [{
                    label: window.t('lblData'),
                    data: values,
                    backgroundColor: type === 'pie' ? colors : colors[0] + '80',
                    borderColor: type === 'pie' ? colors : colors[0],
                    borderWidth: 2,
                    tension: 0.4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: type === 'pie',
                        position: 'right'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                if (type === 'pie') {
                                    const label = context.label || '';
                                    const value = context.parsed;
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = ((value / total) * 100).toFixed(1);
                                    return `${label}: ${value} (${percentage}%)`;
                                }
                                return context.formattedValue;
                            }
                        }
                    },
                    datalabels: type === 'pie' ? {
                        color: '#fff',
                        font: {
                            weight: 'bold',
                            size: 14
                        },
                        formatter: (value, ctx) => {
                            const total = ctx.dataset.data.reduce((a, b) => a + b, 0);
                            const percentage = ((value / total) * 100).toFixed(1);
                            return percentage + '%';
                        }
                    } : false
                },
                scales: type === 'pie' ? {} : {
                    y: {
                        beginAtZero: true
                    }
                }
            },
            plugins: plugins
        };

        this.chart = new Chart(this.ctx, config);
    }

    // Render 3D shape
    render3DShape(shape, params = {}) {
        this.clear();
        this.currentMode = 'shape';
        this.currentShape = shape;
        this.shapeParams = params;

        const width = this.canvas.width;
        const height = this.canvas.height;
        const centerX = width / 2;
        const centerY = height / 2;

        this.ctx.strokeStyle = '#333';
        this.ctx.lineWidth = 2;
        this.ctx.fillStyle = '#667eea40';

        // Apply zoom to all parameters
        const zoomedParams = {};
        for (let key in params) {
            zoomedParams[key] = params[key] * this.zoom;
        }

        switch (shape) {
            case 'cube':
                this.drawCube(centerX, centerY, zoomedParams.size || 150 * this.zoom);
                break;
            case 'cuboid':
                this.drawCuboid(centerX, centerY, 
                    zoomedParams.width || 180 * this.zoom, 
                    zoomedParams.height || 120 * this.zoom, 
                    zoomedParams.depth || 100 * this.zoom);
                break;
            case 'pyramid':
                this.drawPyramid(centerX, centerY, 
                    zoomedParams.baseSize || 150 * this.zoom, 
                    zoomedParams.height || 180 * this.zoom);
                break;
            case 'cylinder':
                this.drawCylinder(centerX, centerY, 
                    zoomedParams.radius || 80 * this.zoom, 
                    zoomedParams.height || 200 * this.zoom);
                break;
            case 'sphere':
                this.drawSphere(centerX, centerY, zoomedParams.radius || 100 * this.zoom);
                break;
            case 'cone':
                this.drawCone(centerX, centerY, 
                    zoomedParams.radius || 80 * this.zoom, 
                    zoomedParams.height || 180 * this.zoom);
                break;
        }
    }
    
    // Update rotation
    setRotation(x, y, z) {
        this.rotation = { x, y, z };
        this.updateShape();
    }
    
    // Update zoom
    setZoom(zoom) {
        this.zoom = zoom;
        this.updateShape();
    }
    
    // Re-render current shape with updated transformations
    updateShape() {
        if (this.currentMode === 'shape' && this.currentShape) {
            this.render3DShape(this.currentShape, this.shapeParams);
        }
    }
    
    // Reset view to defaults
    resetView() {
        this.rotation = { x: 30, y: 45, z: 0 };
        this.zoom = 1.0;
        this.updateShape();
    }
    
    // Apply 3D rotation to a point [x, y, z]
    rotate3D(point) {
        const [x, y, z] = point;
        
        // Convert rotation angles to radians
        const rx = this.rotation.x * Math.PI / 180;
        const ry = this.rotation.y * Math.PI / 180;
        const rz = this.rotation.z * Math.PI / 180;
        
        // Apply rotations in order: Y, X, Z (for better visual control)
        // Rotation around Y axis (pitch - left/right turn)
        let x1 = x * Math.cos(ry) + z * Math.sin(ry);
        let y1 = y;
        let z1 = -x * Math.sin(ry) + z * Math.cos(ry);
        
        // Rotation around X axis (roll - tilt forward/back)
        let x2 = x1;
        let y2 = y1 * Math.cos(rx) - z1 * Math.sin(rx);
        let z2 = y1 * Math.sin(rx) + z1 * Math.cos(rx);
        
        // Rotation around Z axis (yaw - screen rotation)
        let x3 = x2 * Math.cos(rz) - y2 * Math.sin(rz);
        let y3 = x2 * Math.sin(rz) + y2 * Math.cos(rz);
        let z3 = z2;
        
        return [x3, y3, z3];
    }
    
    // Project 3D point to 2D canvas (isometric-like projection)
    project3D(point, cx, cy) {
        const [x, y, z] = this.rotate3D(point);
        
        // Orthographic projection with isometric-style scaling
        const scale = 1;
        const canvasX = cx + x * scale;
        const canvasY = cy - y * scale - z * 0.5 * scale; // Y is up, Z adds depth
        
        return [canvasX, canvasY];
    }

    // 3D shape drawing methods with proper rotation
    drawCube(cx, cy, size) {
        const s = size / 2;
        
        // Define 8 vertices of the cube in 3D space
        const vertices = [
            [-s, -s, -s], // 0: back-bottom-left
            [s, -s, -s],  // 1: back-bottom-right
            [s, s, -s],   // 2: back-top-right
            [-s, s, -s],  // 3: back-top-left
            [-s, -s, s],  // 4: front-bottom-left
            [s, -s, s],   // 5: front-bottom-right
            [s, s, s],    // 6: front-top-right
            [-s, s, s]    // 7: front-top-left
        ];
        
        // Project vertices to 2D
        const projected = vertices.map(v => this.project3D(v, cx, cy));
        
        // Define faces (indices into vertices array)
        const faces = [
            [0, 1, 2, 3], // back
            [4, 5, 6, 7], // front
            [0, 1, 5, 4], // bottom
            [2, 3, 7, 6], // top
            [0, 3, 7, 4], // left
            [1, 2, 6, 5]  // right
        ];
        
        // Calculate face centers for depth sorting
        const facesWithDepth = faces.map((face, idx) => {
            const center = face.reduce((acc, vi) => {
                const v = vertices[vi];
                return [acc[0] + v[0], acc[1] + v[1], acc[2] + v[2]];
            }, [0, 0, 0]).map(c => c / face.length);
            
            const rotated = this.rotate3D(center);
            return { face, depth: rotated[2], idx };
        });
        
        // Sort faces by depth (back to front)
        facesWithDepth.sort((a, b) => a.depth - b.depth);
        
        // Draw faces
        facesWithDepth.forEach(({ face }) => {
            this.ctx.beginPath();
            this.ctx.moveTo(...projected[face[0]]);
            for (let i = 1; i < face.length; i++) {
                this.ctx.lineTo(...projected[face[i]]);
            }
            this.ctx.closePath();
            this.ctx.fill();
            this.ctx.stroke();
        });
    }

    drawCuboid(cx, cy, w, h, d) {
        const hw = w / 2;
        const hh = h / 2;
        const hd = d / 2;
        
        // Define 8 vertices in 3D space
        const vertices = [
            [-hw, -hh, -hd], // 0
            [hw, -hh, -hd],  // 1
            [hw, hh, -hd],   // 2
            [-hw, hh, -hd],  // 3
            [-hw, -hh, hd],  // 4
            [hw, -hh, hd],   // 5
            [hw, hh, hd],    // 6
            [-hw, hh, hd]    // 7
        ];
        
        const projected = vertices.map(v => this.project3D(v, cx, cy));
        
        const faces = [
            [0, 1, 2, 3], // back
            [4, 5, 6, 7], // front
            [0, 1, 5, 4], // bottom
            [2, 3, 7, 6], // top
            [0, 3, 7, 4], // left
            [1, 2, 6, 5]  // right
        ];
        
        const facesWithDepth = faces.map((face) => {
            const center = face.reduce((acc, vi) => {
                const v = vertices[vi];
                return [acc[0] + v[0], acc[1] + v[1], acc[2] + v[2]];
            }, [0, 0, 0]).map(c => c / face.length);
            
            const rotated = this.rotate3D(center);
            return { face, depth: rotated[2] };
        });
        
        facesWithDepth.sort((a, b) => a.depth - b.depth);
        
        facesWithDepth.forEach(({ face }) => {
            this.ctx.beginPath();
            this.ctx.moveTo(...projected[face[0]]);
            for (let i = 1; i < face.length; i++) {
                this.ctx.lineTo(...projected[face[i]]);
            }
            this.ctx.closePath();
            this.ctx.fill();
            this.ctx.stroke();
        });
    }

    drawPyramid(cx, cy, baseSize, height) {
        const s = baseSize / 2;
        
        // Define vertices in 3D space
        const vertices = [
            [-s, 0, -s],     // 0: base back-left
            [s, 0, -s],      // 1: base back-right
            [s, 0, s],       // 2: base front-right
            [-s, 0, s],      // 3: base front-left
            [0, -height, 0]  // 4: apex
        ];
        
        const projected = vertices.map(v => this.project3D(v, cx, cy));
        
        // Draw base
        this.ctx.beginPath();
        this.ctx.moveTo(...projected[0]);
        for (let i = 1; i < 4; i++) {
            this.ctx.lineTo(...projected[i]);
        }
        this.ctx.closePath();
        this.ctx.fill();
        this.ctx.stroke();
        
        // Draw triangular faces
        const faces = [
            [0, 1, 4], // back
            [1, 2, 4], // right
            [2, 3, 4], // front
            [3, 0, 4]  // left
        ];
        
        const facesWithDepth = faces.map((face) => {
            const center = face.reduce((acc, vi) => {
                const v = vertices[vi];
                return [acc[0] + v[0], acc[1] + v[1], acc[2] + v[2]];
            }, [0, 0, 0]).map(c => c / face.length);
            
            const rotated = this.rotate3D(center);
            return { face, depth: rotated[2] };
        });
        
        facesWithDepth.sort((a, b) => a.depth - b.depth);
        
        facesWithDepth.forEach(({ face }) => {
            this.ctx.beginPath();
            this.ctx.moveTo(...projected[face[0]]);
            this.ctx.lineTo(...projected[face[1]]);
            this.ctx.lineTo(...projected[face[2]]);
            this.ctx.closePath();
            this.ctx.fill();
            this.ctx.stroke();
        });
    }

    drawCylinder(cx, cy, radius, height) {
        const segments = 20;
        const topCircle = [];
        const bottomCircle = [];
        
        // Generate circle vertices in 3D
        for (let i = 0; i <= segments; i++) {
            const angle = (i / segments) * Math.PI * 2;
            const x = radius * Math.cos(angle);
            const z = radius * Math.sin(angle);
            
            topCircle.push([x, -height, z]);
            bottomCircle.push([x, 0, z]);
        }
        
        // Project vertices
        const topProjected = topCircle.map(v => this.project3D(v, cx, cy));
        const bottomProjected = bottomCircle.map(v => this.project3D(v, cx, cy));
        
        // Draw side surface
        for (let i = 0; i < segments; i++) {
            // Calculate if this segment is visible (simple back-face culling)
            const v1 = topCircle[i];
            const v2 = bottomCircle[i];
            const rotated1 = this.rotate3D(v1);
            const rotated2 = this.rotate3D(v2);
            
            // Draw quad for each side segment
            this.ctx.beginPath();
            this.ctx.moveTo(...topProjected[i]);
            this.ctx.lineTo(...topProjected[i + 1]);
            this.ctx.lineTo(...bottomProjected[i + 1]);
            this.ctx.lineTo(...bottomProjected[i]);
            this.ctx.closePath();
            
            // Only fill if facing forward (z > 0)
            if (rotated1[2] > 0 || rotated2[2] > 0) {
                this.ctx.fill();
            }
            this.ctx.stroke();
        }
        
        // Draw top circle
        this.ctx.beginPath();
        this.ctx.moveTo(...topProjected[0]);
        for (let i = 1; i < topProjected.length; i++) {
            this.ctx.lineTo(...topProjected[i]);
        }
        this.ctx.closePath();
        this.ctx.fill();
        this.ctx.stroke();
        
        // Draw bottom circle
        this.ctx.beginPath();
        this.ctx.moveTo(...bottomProjected[0]);
        for (let i = 1; i < bottomProjected.length; i++) {
            this.ctx.lineTo(...bottomProjected[i]);
        }
        this.ctx.closePath();
        this.ctx.fill();
        this.ctx.stroke();
    }

    drawSphere(cx, cy, radius) {
        const segments = 16;
        const rings = 8;
        
        // Generate sphere vertices
        const vertices = [];
        for (let ring = 0; ring <= rings; ring++) {
            const phi = (ring / rings) * Math.PI;
            const y = -radius * Math.cos(phi);
            const ringRadius = radius * Math.sin(phi);
            
            for (let seg = 0; seg <= segments; seg++) {
                const theta = (seg / segments) * Math.PI * 2;
                const x = ringRadius * Math.cos(theta);
                const z = ringRadius * Math.sin(theta);
                
                vertices.push([x, y, z]);
            }
        }
        
        // Project all vertices
        const projected = vertices.map(v => this.project3D(v, cx, cy));
        
        // Draw wireframe
        this.ctx.strokeStyle = '#66666660';
        
        // Draw latitude lines
        for (let ring = 0; ring <= rings; ring++) {
            this.ctx.beginPath();
            for (let seg = 0; seg <= segments; seg++) {
                const idx = ring * (segments + 1) + seg;
                if (seg === 0) {
                    this.ctx.moveTo(...projected[idx]);
                } else {
                    this.ctx.lineTo(...projected[idx]);
                }
            }
            this.ctx.stroke();
        }
        
        // Draw longitude lines
        for (let seg = 0; seg < segments; seg++) {
            this.ctx.beginPath();
            for (let ring = 0; ring <= rings; ring++) {
                const idx = ring * (segments + 1) + seg;
                if (ring === 0) {
                    this.ctx.moveTo(...projected[idx]);
                } else {
                    this.ctx.lineTo(...projected[idx]);
                }
            }
            this.ctx.stroke();
        }
        
        this.ctx.strokeStyle = '#333';
        
        // Draw outline circle
        this.ctx.beginPath();
        this.ctx.arc(cx, cy, radius * 0.9, 0, Math.PI * 2);
        this.ctx.stroke();
    }

    drawCone(cx, cy, radius, height) {
        const segments = 20;
        const baseCircle = [];
        
        // Generate base circle vertices in 3D
        for (let i = 0; i <= segments; i++) {
            const angle = (i / segments) * Math.PI * 2;
            const x = radius * Math.cos(angle);
            const z = radius * Math.sin(angle);
            
            baseCircle.push([x, 0, z]);
        }
        
        // Apex point
        const apex = [0, -height, 0];
        
        // Project vertices
        const baseProjected = baseCircle.map(v => this.project3D(v, cx, cy));
        const apexProjected = this.project3D(apex, cx, cy);
        
        // Draw side surface
        for (let i = 0; i < segments; i++) {
            const v1 = baseCircle[i];
            const rotated = this.rotate3D(v1);
            
            // Draw triangle for each side segment
            this.ctx.beginPath();
            this.ctx.moveTo(...apexProjected);
            this.ctx.lineTo(...baseProjected[i]);
            this.ctx.lineTo(...baseProjected[i + 1]);
            this.ctx.closePath();
            
            // Only fill if facing forward
            if (rotated[2] > 0) {
                this.ctx.fill();
            }
            this.ctx.stroke();
        }
        
        // Draw base circle
        this.ctx.beginPath();
        this.ctx.moveTo(...baseProjected[0]);
        for (let i = 1; i < baseProjected.length; i++) {
            this.ctx.lineTo(...baseProjected[i]);
        }
        this.ctx.closePath();
        this.ctx.fill();
        this.ctx.stroke();
    }

    // Helper methods
    drawLine(x1, y1, x2, y2) {
        this.ctx.beginPath();
        this.ctx.moveTo(x1, y1);
        this.ctx.lineTo(x2, y2);
        this.ctx.stroke();
    }

    drawFace(vertices) {
        this.ctx.beginPath();
        this.ctx.moveTo(...vertices[0]);
        for (let i = 1; i < vertices.length; i++) {
            this.ctx.lineTo(...vertices[i]);
        }
        this.ctx.closePath();
        this.ctx.fill();
        this.ctx.stroke();
    }
}

// 2D Transformations Controller

class TransformationsController {
    constructor() {
        this.canvas = null;
        this.ctx = null;
        this.currentShape = 'triangle';
        this.originalPoints = [];
        this.transformedPoints = [];
        
        // Transformation parameters
        this.translation = { x: 0, y: 0 };
        this.rotation = 0; // degrees
        this.scale = 1;
        this.rotationCenter = { x: 0, y: 0 }; // center of rotation
        
        // Display options
        this.showOriginalShape = true;
        this.showGrid = true;
        this.showRotationCenter = true;
        
        // Grid settings
        this.gridSize = 1;
        this.gridOriginX = 0;
        this.gridOriginY = 0;
    }

    init(canvasId) {
        this.canvas = document.getElementById(canvasId);
        if (!this.canvas) {
            console.error('Transform canvas not found');
            return;
        }
        this.ctx = this.canvas.getContext('2d');
        this.resizeCanvas();
        
        // Initialize with triangle
        this.setShape('triangle');
        
        // Add resize listener
        window.addEventListener('resize', () => this.resizeCanvas());
    }

    resizeCanvas() {
        const container = this.canvas.parentElement;
        const rect = container.getBoundingClientRect();
        this.canvas.width = rect.width - 40;
        this.canvas.height = rect.height - 40;
        this.render();
    }

    setRotationCenter(x, y) {
        this.rotationCenter.x = x;
        this.rotationCenter.y = y;
        this.render();
    }
    
    calculateShapeCentroid() {
        if (this.points.length === 0) return { x: 0, y: 0 };
        
        let sumX = 0;
        let sumY = 0;
        for (let point of this.points) {
            sumX += point.x;
            sumY += point.y;
        }
        return {
            x: sumX / this.points.length,
            y: sumY / this.points.length
        };
    }
    
    setRotationCenterToShape() {
        const centroid = this.calculateShapeCentroid();
        this.rotationCenter.x = centroid.x;
        this.rotationCenter.y = centroid.y;
        this.render();
        return centroid;
    }

    setShape(shapeName) {
        this.currentShape = shapeName;
        
        // Define original points for each shape (in grid coordinates)
        switch (shapeName) {
            case 'triangle':
                this.originalPoints = [
                    [0, 0],
                    [3, 0],
                    [1.5, 3]
                ];
                break;
            case 'square':
                this.originalPoints = [
                    [0, 0],
                    [2, 0],
                    [2, 2],
                    [0, 2]
                ];
                break;
            case 'rectangle':
                this.originalPoints = [
                    [0, 0],
                    [4, 0],
                    [4, 2],
                    [0, 2]
                ];
                break;
            case 'circle':
                // Approximate circle with many points
                this.originalPoints = [];
                const radius = 2;
                const segments = 32;
                for (let i = 0; i <= segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;
                    this.originalPoints.push([
                        radius * Math.cos(angle),
                        radius * Math.sin(angle)
                    ]);
                }
                break;
            case 'polygon':
                // Pentagon
                this.originalPoints = [];
                const sides = 5;
                const r = 2;
                for (let i = 0; i < sides; i++) {
                    const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;
                    this.originalPoints.push([
                        r * Math.cos(angle),
                        r * Math.sin(angle)
                    ]);
                }
                break;
        }
        
        this.applyTransformations();
        this.render();
    }

    setCustomPoints(pointsText) {
        const lines = pointsText.trim().split('\n');
        this.originalPoints = [];
        
        for (let line of lines) {
            const coords = line.split(',').map(s => parseFloat(s.trim()));
            if (coords.length === 2 && !isNaN(coords[0]) && !isNaN(coords[1])) {
                this.originalPoints.push(coords);
            }
        }
        
        if (this.originalPoints.length > 0) {
            this.currentShape = 'custom';
            this.applyTransformations();
            this.render();
        }
    }

    setTranslation(x, y) {
        this.translation = { x, y };
        this.applyTransformations();
        this.render();
    }

    setRotation(degrees) {
        this.rotation = degrees;
        this.applyTransformations();
        this.render();
    }

    setScale(scale) {
        this.scale = scale;
        this.applyTransformations();
        this.render();
    }

    // Apply all transformations to create transformed points
    applyTransformations() {
        const cx = this.rotationCenter.x;
        const cy = this.rotationCenter.y;
        
        this.transformedPoints = this.originalPoints.map(point => {
            let [x, y] = point;
            
            // Apply scale
            x *= this.scale;
            y *= this.scale;
            
            // Apply rotation around custom center
            // Translate to rotation center, rotate, translate back
            const rad = this.rotation * Math.PI / 180;
            const cos = Math.cos(rad);
            const sin = Math.sin(rad);
            const dx = x - cx;
            const dy = y - cy;
            const rx = cx + (dx * cos - dy * sin);
            const ry = cy + (dx * sin + dy * cos);
            
            // Apply translation
            return [rx + this.translation.x, ry + this.translation.y];
        });
    }

    // Special transformations
    reflectX() {
        this.originalPoints = this.transformedPoints.map(([x, y]) => [x, -y]);
        this.resetTransformParams();
        this.render();
    }

    reflectY() {
        this.originalPoints = this.transformedPoints.map(([x, y]) => [-x, y]);
        this.resetTransformParams();
        this.render();
    }

    reflectOrigin() {
        this.originalPoints = this.transformedPoints.map(([x, y]) => [-x, -y]);
        this.resetTransformParams();
        this.render();
    }

    reflectYeqX() {
        this.originalPoints = this.transformedPoints.map(([x, y]) => [y, x]);
        this.resetTransformParams();
        this.render();
    }

    shearX() {
        const factor = 0.5;
        this.originalPoints = this.transformedPoints.map(([x, y]) => [x + factor * y, y]);
        this.resetTransformParams();
        this.render();
    }

    shearY() {
        const factor = 0.5;
        this.originalPoints = this.transformedPoints.map(([x, y]) => [x, y + factor * x]);
        this.resetTransformParams();
        this.render();
    }

    rotate90() {
        this.originalPoints = this.transformedPoints.map(([x, y]) => [-y, x]);
        this.resetTransformParams();
        this.render();
    }

    rotate180() {
        this.originalPoints = this.transformedPoints.map(([x, y]) => [-x, -y]);
        this.resetTransformParams();
        this.render();
    }

    resetTransformParams() {
        this.translation = { x: 0, y: 0 };
        this.rotation = 0;
        this.scale = 1;
        this.rotationCenter = { x: 0, y: 0 };
        this.applyTransformations();
    }

    resetAll() {
        this.setShape(this.currentShape);
        this.resetTransformParams();
    }

    toggleOriginal() {
        this.showOriginalShape = !this.showOriginalShape;
        this.render();
    }

    toggleGrid() {
        this.showGrid = !this.showGrid;
        this.render();
    }

    // Convert grid coordinates to canvas coordinates
    gridToCanvas(x, y) {
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;
        const scale = 30; // pixels per grid unit
        
        return [
            centerX + x * scale,
            centerY - y * scale // Invert Y for standard coordinate system
        ];
    }

    render() {
        const width = this.canvas.width;
        const height = this.canvas.height;
        
        // Clear canvas
        this.ctx.fillStyle = '#fafafa';
        this.ctx.fillRect(0, 0, width, height);
        
        // Draw grid
        if (this.showGrid) {
            this.drawGrid();
        }
        
        // Draw axes
        this.drawAxes();
        
        // Draw original shape
        if (this.showOriginalShape && this.originalPoints.length > 0) {
            this.drawShape(this.originalPoints, '#cccccc', '#999999', 2, true);
        }
        
        // Draw transformed shape
        if (this.transformedPoints.length > 0) {
            this.drawShape(this.transformedPoints, '#667eea', '#4a5fd7', 3, false);
        }
        
        // Draw rotation center
        if (this.showRotationCenter) {
            this.drawRotationCenter();
        }
    }

    drawGrid() {
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;
        const scale = 30;
        
        this.ctx.strokeStyle = '#e8e8e8';
        this.ctx.lineWidth = 1;
        
        // Vertical lines
        for (let x = 0; x < this.canvas.width; x += scale) {
            this.ctx.beginPath();
            this.ctx.moveTo(x, 0);
            this.ctx.lineTo(x, this.canvas.height);
            this.ctx.stroke();
        }
        
        // Horizontal lines
        for (let y = 0; y < this.canvas.height; y += scale) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(this.canvas.width, y);
            this.ctx.stroke();
        }
    }

    drawAxes() {
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;
        
        // X axis
        this.ctx.strokeStyle = '#333';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.moveTo(0, centerY);
        this.ctx.lineTo(this.canvas.width, centerY);
        this.ctx.stroke();
        
        // Y axis
        this.ctx.beginPath();
        this.ctx.moveTo(centerX, 0);
        this.ctx.lineTo(centerX, this.canvas.height);
        this.ctx.stroke();
        
        // Labels
        this.ctx.fillStyle = '#333';
        this.ctx.font = '14px Arial';
        this.ctx.fillText('x', this.canvas.width - 20, centerY - 10);
        this.ctx.fillText('y', centerX + 10, 20);
        this.ctx.fillText('O', centerX + 5, centerY + 20);
        
        // Draw grid numbers
        const scale = 30;
        this.ctx.font = '11px Arial';
        this.ctx.fillStyle = '#666';
        
        // X axis numbers
        for (let i = -10; i <= 10; i++) {
            if (i !== 0) {
                const x = centerX + i * scale;
                if (x >= 0 && x <= this.canvas.width) {
                    this.ctx.fillText(i.toString(), x - 5, centerY + 20);
                }
            }
        }
        
        // Y axis numbers
        for (let i = -10; i <= 10; i++) {
            if (i !== 0) {
                const y = centerY - i * scale;
                if (y >= 0 && y <= this.canvas.height) {
                    this.ctx.fillText(i.toString(), centerX + 10, y + 5);
                }
            }
        }
    }

    drawShape(points, fillColor, strokeColor, lineWidth, dashed) {
        if (points.length === 0) return;
        
        // Convert points to canvas coordinates
        const canvasPoints = points.map(([x, y]) => this.gridToCanvas(x, y));
        
        // Draw shape
        this.ctx.fillStyle = fillColor + '40';
        this.ctx.strokeStyle = strokeColor;
        this.ctx.lineWidth = lineWidth;
        
        if (dashed) {
            this.ctx.setLineDash([5, 5]);
        } else {
            this.ctx.setLineDash([]);
        }
        
        this.ctx.beginPath();
        this.ctx.moveTo(...canvasPoints[0]);
        for (let i = 1; i < canvasPoints.length; i++) {
            this.ctx.lineTo(...canvasPoints[i]);
        }
        
        // Close path for filled shapes (not for circles)
        if (this.currentShape !== 'circle') {
            this.ctx.closePath();
        }
        
        this.ctx.fill();
        this.ctx.stroke();
        
        // Draw vertices
        this.ctx.fillStyle = strokeColor;
        canvasPoints.forEach(([x, y]) => {
            this.ctx.beginPath();
            this.ctx.arc(x, y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        });
        
        this.ctx.setLineDash([]);
    }
    
    drawRotationCenter() {
        const [x, y] = this.gridToCanvas(this.rotationCenter.x, this.rotationCenter.y);
        
        // Draw crosshair
        this.ctx.strokeStyle = '#e74c3c'; // Red color
        this.ctx.lineWidth = 2;
        this.ctx.setLineDash([]);
        
        const size = 8;
        
        // Horizontal line
        this.ctx.beginPath();
        this.ctx.moveTo(x - size, y);
        this.ctx.lineTo(x + size, y);
        this.ctx.stroke();
        
        // Vertical line
        this.ctx.beginPath();
        this.ctx.moveTo(x, y - size);
        this.ctx.lineTo(x, y + size);
        this.ctx.stroke();
        
        // Circle
        this.ctx.beginPath();
        this.ctx.arc(x, y, 5, 0, Math.PI * 2);
        this.ctx.stroke();
    }
}

// Freeform Drawing Controller
class DrawingController {
    constructor() {
        this.canvas = null;
        this.ctx = null;
        this.isDrawing = false;
        this.currentTool = 'pen';
        this.currentColor = '#000000';
        this.brushSize = 3;
        this.backgroundColor = '#ffffff';
        this.showGrid = false;
        this.gridSize = 20;
        
        // For shapes
        this.startX = 0;
        this.startY = 0;
        this.tempCanvas = null;
        this.tempCtx = null;
        
        // Drawing layer (without grid)
        this.drawingCanvas = null;
        this.drawingCtx = null;
        
        // History for undo
        this.history = [];
        this.maxHistory = 20;
    }

    init(canvasId) {
        this.canvas = document.getElementById(canvasId);
        if (!this.canvas) {
            console.error('Drawing canvas not found');
            return;
        }

        this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
        
        // Create temporary canvas for shape preview
        this.tempCanvas = document.createElement('canvas');
        this.tempCtx = this.tempCanvas.getContext('2d', { willReadFrequently: true });
        
        // Create drawing layer canvas (holds actual drawing without grid)
        this.drawingCanvas = document.createElement('canvas');
        this.drawingCtx = this.drawingCanvas.getContext('2d', { willReadFrequently: true });
        this.tempCtx = this.tempCanvas.getContext('2d');
        
        this.resizeCanvas();
        
        // Add event listeners
        this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
        this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
        this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
        this.canvas.addEventListener('mouseleave', this.handleMouseUp.bind(this));
        
        // Touch support
        this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this));
        this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this));
        this.canvas.addEventListener('touchend', this.handleMouseUp.bind(this));
        
        console.log('Drawing controller initialized');
    }

    resizeCanvas() {
        const container = this.canvas.parentElement;
        this.canvas.width = container.clientWidth;
        this.canvas.height = container.clientHeight;
        
        this.tempCanvas.width = this.canvas.width;
        this.tempCanvas.height = this.canvas.height;
        
        this.drawingCanvas.width = this.canvas.width;
        this.drawingCanvas.height = this.canvas.height;
        
        // Initialize drawing layer - NO BACKGROUND, keep it transparent
        if (this.canvas.width > 0 && this.canvas.height > 0) {
            // Don't fill the drawing layer - it should be transparent
            // so the grid shows through
            
            this.render();
            
            // Save initial state to history if not already saved
            if (this.history.length === 0) {
                this.saveToHistory();
            }
        }
    }
    
    render() {
        // Clear display canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Draw background
        if (this.backgroundColor !== 'transparent') {
            this.ctx.fillStyle = this.backgroundColor;
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        }
        
        //console.log('Rendering, showGrid:', this.showGrid);
        
        // Draw grid if enabled
        if (this.showGrid) {
            this.drawGrid();
        }
        
        // Draw the drawing layer on top
        this.ctx.drawImage(this.drawingCanvas, 0, 0);
    }
    
    redrawBackground() {
        // Clear the drawing layer - keep it transparent
        this.drawingCtx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.render();
    }
    
    drawGrid() {
        // Make grid more visible with darker color
        if (this.backgroundColor === '#000000') {
            this.ctx.strokeStyle = '#666666';
        } else if (this.backgroundColor === 'transparent') {
            this.ctx.strokeStyle = '#cccccc';
        } else {
            // White background - use a much darker gray
            this.ctx.strokeStyle = '#cccccc';
        }
        
        this.ctx.lineWidth = 1;
        this.ctx.setLineDash([]);
        
        //console.log('Drawing grid with color:', this.ctx.strokeStyle, 'size:', this.gridSize);
        
        // Vertical lines
        for (let x = 0; x <= this.canvas.width; x += this.gridSize) {
            this.ctx.beginPath();
            this.ctx.moveTo(x, 0);
            this.ctx.lineTo(x, this.canvas.height);
            this.ctx.stroke();
        }
        
        // Horizontal lines
        for (let y = 0; y <= this.canvas.height; y += this.gridSize) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(this.canvas.width, y);
            this.ctx.stroke();
        }
    }

    handleMouseDown(e) {
        const rect = this.canvas.getBoundingClientRect();
        this.startX = e.clientX - rect.left;
        this.startY = e.clientY - rect.top;
        this.isDrawing = true;
        
        if (this.currentTool === 'pen' || this.currentTool === 'eraser') {
            this.drawingCtx.beginPath();
            this.drawingCtx.moveTo(this.startX, this.startY);
        } else if (this.currentTool === 'text') {
            this.addText(this.startX, this.startY);
        } else {
            // For shapes, save current state
            this.saveTemp();
        }
    }

    handleMouseMove(e) {
        if (!this.isDrawing) return;
        
        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        if (this.currentTool === 'pen') {
            this.drawLine(this.startX, this.startY, x, y);
            this.startX = x;
            this.startY = y;
        } else if (this.currentTool === 'eraser') {
            this.erase(x, y);
        } else if (this.currentTool === 'line') {
            this.restoreTemp();
            this.drawStraightLinePreview(this.startX, this.startY, x, y);
        } else if (this.currentTool === 'rectangle') {
            this.restoreTemp();
            this.drawRectanglePreview(this.startX, this.startY, x, y);
        } else if (this.currentTool === 'circle') {
            this.restoreTemp();
            this.drawCirclePreview(this.startX, this.startY, x, y);
        }
    }

    handleMouseUp(e) {
        if (this.isDrawing && this.currentTool !== 'text') {
            // For shapes, finalize the drawing
            if (this.currentTool === 'line' || this.currentTool === 'rectangle' || this.currentTool === 'circle') {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Draw final shape on drawing layer
                if (this.currentTool === 'line') {
                    this.drawStraightLine(this.startX, this.startY, x, y);
                } else if (this.currentTool === 'rectangle') {
                    this.drawRectangle(this.startX, this.startY, x, y);
                } else if (this.currentTool === 'circle') {
                    this.drawCircle(this.startX, this.startY, x, y);
                }
            }
            
            this.saveToHistory();
            this.render();
        }
        this.isDrawing = false;
    }

    handleTouchStart(e) {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent('mousedown', {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        this.canvas.dispatchEvent(mouseEvent);
    }

    handleTouchMove(e) {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent('mousemove', {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        this.canvas.dispatchEvent(mouseEvent);
    }

    drawLine(x1, y1, x2, y2) {
        this.drawingCtx.strokeStyle = this.currentColor;
        this.drawingCtx.lineWidth = this.brushSize;
        this.drawingCtx.lineCap = 'round';
        this.drawingCtx.lineJoin = 'round';
        
        this.drawingCtx.lineTo(x2, y2);
        this.drawingCtx.stroke();
        this.render();
    }

    drawStraightLine(x1, y1, x2, y2) {
        this.drawingCtx.strokeStyle = this.currentColor;
        this.drawingCtx.lineWidth = this.brushSize;
        this.drawingCtx.lineCap = 'round';
        
        this.drawingCtx.beginPath();
        this.drawingCtx.moveTo(x1, y1);
        this.drawingCtx.lineTo(x2, y2);
        this.drawingCtx.stroke();
    }
    
    drawStraightLinePreview(x1, y1, x2, y2) {
        // Draw preview on display canvas, then render to show it
        this.render();
        
        this.ctx.strokeStyle = this.currentColor;
        this.ctx.lineWidth = this.brushSize;
        this.ctx.lineCap = 'round';
        
        this.ctx.beginPath();
        this.ctx.moveTo(x1, y1);
        this.ctx.lineTo(x2, y2);
        this.ctx.stroke();
    }

    drawRectangle(x1, y1, x2, y2) {
        const width = x2 - x1;
        const height = y2 - y1;
        
        this.drawingCtx.strokeStyle = this.currentColor;
        this.drawingCtx.lineWidth = this.brushSize;
        this.drawingCtx.strokeRect(x1, y1, width, height);
    }
    
    drawRectanglePreview(x1, y1, x2, y2) {
        const width = x2 - x1;
        const height = y2 - y1;
        
        // Draw preview on display canvas
        this.render();
        
        this.ctx.strokeStyle = this.currentColor;
        this.ctx.lineWidth = this.brushSize;
        this.ctx.strokeRect(x1, y1, width, height);
    }

    drawCircle(x1, y1, x2, y2) {
        const radius = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        
        this.drawingCtx.strokeStyle = this.currentColor;
        this.drawingCtx.lineWidth = this.brushSize;
        this.drawingCtx.beginPath();
        this.drawingCtx.arc(x1, y1, radius, 0, Math.PI * 2);
        this.drawingCtx.stroke();
    }
    
    drawCirclePreview(x1, y1, x2, y2) {
        const radius = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        
        // Draw preview on display canvas
        this.render();
        
        this.ctx.strokeStyle = this.currentColor;
        this.ctx.lineWidth = this.brushSize;
        this.ctx.beginPath();
        this.ctx.arc(x1, y1, radius, 0, Math.PI * 2);
        this.ctx.stroke();
    }

    erase(x, y) {
        // Erase by clearing to transparent on the drawing layer
        this.drawingCtx.clearRect(
            x - this.brushSize / 2,
            y - this.brushSize / 2,
            this.brushSize * 2,
            this.brushSize * 2
        );
        this.render();
    }

    addText(x, y) {
        const text = prompt(window.t('msgEnterText'));
        if (text) {
            this.drawingCtx.font = `${this.brushSize * 8}px Arial`;
            this.drawingCtx.fillStyle = this.currentColor;
            this.drawingCtx.fillText(text, x, y);
            this.saveToHistory();
            this.render();
        }
        this.isDrawing = false;
    }

    saveTemp() {
        this.tempCtx.clearRect(0, 0, this.tempCanvas.width, this.tempCanvas.height);
        this.tempCtx.drawImage(this.drawingCanvas, 0, 0);
    }

    restoreTemp() {
        this.drawingCtx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.drawingCtx.drawImage(this.tempCanvas, 0, 0);
        this.render();
    }

    saveToHistory() {
        // Only save if canvas has valid dimensions - save the drawing layer only
        if (this.canvas.width > 0 && this.canvas.height > 0) {
            const imageData = this.drawingCtx.getImageData(0, 0, this.canvas.width, this.canvas.height);
            this.history.push(imageData);
            
            if (this.history.length > this.maxHistory) {
                this.history.shift();
            }
        }
    }

    undo() {
        if (this.history.length > 0) {
            this.history.pop(); // Remove current state
            
            if (this.history.length > 0) {
                const previousState = this.history[this.history.length - 1];
                this.drawingCtx.putImageData(previousState, 0, 0);
                this.render();
            } else {
                this.clearCanvas();
            }
        }
    }

    setTool(tool) {
        this.currentTool = tool;
    }

    setColor(color) {
        this.currentColor = color;
    }

    setBrushSize(size) {
        this.brushSize = size;
    }

    setBackgroundColor(color) {
        this.backgroundColor = color;
        this.clearCanvas();
    }

    clearCanvas() {
        if (this.canvas.width === 0 || this.canvas.height === 0) {
            return; // Canvas not properly sized yet
        }
        
        this.redrawBackground();
        this.history = [];
        this.saveToHistory();
    }
    
    toggleGrid() {
        this.showGrid = !this.showGrid;
        console.log('Grid toggled, showGrid:', this.showGrid);
        this.render();
    }
    
    setGridSize(size) {
        this.gridSize = size;
        if (this.showGrid) {
            this.render();
        }
    }

    saveImage() {
        const link = document.createElement('a');
        link.download = 'drawing.png';
        link.href = this.canvas.toDataURL();
        link.click();
    }
}

// Main Application Controller
class MathExpressionApp {
    constructor() {
        this.expression = new MathExpression();
        this.navContext = new NavigationContext();
        this.navigationSystem = new NavigationSystem(this.expression, this.navContext);
        this.keyboardController = null;
        this.graphingController = null;
        this.transformationsController = null;
        this.drawingController = null;
        
        this.displayElement = null;
        this.navRenderer = null;
        this.currentTab = 'editor';
        this.currentLanguage = 'en';
    }

    // Initialize the application
    init() {
        // Initialize language
        this.initLanguage();

        // Get DOM elements
        this.displayElement = document.getElementById('expressionDisplay');
        
        if (!this.displayElement) {
            console.error('Expression display element not found');
            return;
        }

        // Initialize navigation renderer
        this.navRenderer = new NavigationRenderer(this.displayElement);

        // Initialize keyboard controller
        this.keyboardController = new KeyboardController(
            this.expression,
            this.navContext,
            () => this.render()
        );
        this.keyboardController.init();

        // Initialize graphing controller
        this.graphingController = new GraphingController();
        this.graphingController.init('graphCanvas');
        
        // Initialize transformations controller
        this.transformationsController = new TransformationsController();
        this.transformationsController.init('transformCanvas');
        
        // Initialize drawing controller
        this.drawingController = new DrawingController();
        this.drawingController.init('drawingCanvas');

        // Initialize control buttons
        this.initControls();
        
        // Initialize tabs
        this.initTabs();
        
        // Initialize graphing controls
        this.initGraphingControls();
        
        // Initialize transformation controls
        this.initTransformationControls();
        
        // Initialize drawing controls
        this.initDrawingControls();

        // Initialize evaluation
        this.initEvaluation();

        // Initialize mouse click handling
        this.initMouseHandling();

        // Initial render
        this.render();

        console.log('Math Expression Editor initialized');
    }
    
    // Initialize language
    initLanguage() {
        const langSelect = document.getElementById('languageSelect');
        if (langSelect) {
            langSelect.addEventListener('change', (e) => {
                this.setLanguage(e.target.value);
            });
        }
        
        // Set initial language
        this.setLanguage('en');
        
        // Make translation function global
        window.t = (key) => {
            if (translations[this.currentLanguage] && translations[this.currentLanguage][key]) {
                return translations[this.currentLanguage][key];
            }
            return key;
        };
        
        // Also expose current language
        window.currentLanguage = this.currentLanguage;
    }
    
    setLanguage(lang) {
        if (!translations[lang]) return;
        
        this.currentLanguage = lang;
        window.currentLanguage = lang;
        
        // Update all elements with data-i18n attribute
        const elements = document.querySelectorAll('[data-i18n]');
        elements.forEach(el => {
            const key = el.getAttribute('data-i18n');
            if (translations[lang][key]) {
                // Check if it's an input with placeholder
                if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') {
                    if (el.hasAttribute('placeholder')) {
                        // For inputs, we might want to translate placeholder
                        // But currently our keys are mostly for text content
                        // If we have specific placeholder keys, we'd use them
                    }
                } else {
                    el.textContent = translations[lang][key];
                }
            }
        });
        
        // Update specific placeholders if needed
        if (lang === 'hy') {
            document.getElementById('functionInput').placeholder = '÷Ö÷Ä’´’∂’°’Ø’ù x^2, sin(x)';
            document.getElementById('chartLabels').placeholder = '‘±, ‘≤, ‘≥, ‘¥';
        } else {
            document.getElementById('functionInput').placeholder = 'e.g., x^2, sin(x), x^3 - 2*x';
            document.getElementById('chartLabels').placeholder = 'A, B, C, D';
        }
        
        // Re-render shape inputs if they exist (to update labels)
        if (this.graphingController && this.graphingController.currentShape) {
            this.generateShapeInputs(this.graphingController.currentShape);
        }
    }
    
    // Initialize tab navigation
    initTabs() {
        const tabBtns = document.querySelectorAll('.tab-btn');
        const tabContents = document.querySelectorAll('.tab-content');
        
        tabBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const tabName = btn.dataset.tab;
                
                // Update active tab button
                tabBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                // Update active tab content
                tabContents.forEach(content => {
                    if (content.id === tabName + 'Tab') {
                        content.classList.add('active');
                    } else {
                        content.classList.remove('active');
                    }
                });
                
                this.currentTab = tabName;
                
                // Show/hide editor controls based on active tab
                this.updateControlsVisibility(tabName);
                
                // Enable/disable keyboard controller based on active tab
                if (this.keyboardController) {
                    this.keyboardController.setEnabled(tabName === 'editor');
                }
                
                // Resize canvas when switching to graphing tab
                if (tabName === 'graphing') {
                    setTimeout(() => this.graphingController.resizeCanvas(), 100);
                }
                
                // Resize canvas when switching to transformations tab
                if (tabName === 'transformations') {
                    setTimeout(() => this.transformationsController.resizeCanvas(), 100);
                }
                
                // Resize canvas when switching to drawing tab
                if (tabName === 'drawing') {
                    setTimeout(() => this.drawingController.resizeCanvas(), 100);
                }
            });
        });
    }
    
    updateControlsVisibility(tabName) {
        const editorControls = document.querySelectorAll('#clearBtn, #undoBtn, #exportBtn, #exportJpegBtn, #importJpegBtn, #evaluateBtn');
        
        if (tabName === 'editor') {
            editorControls.forEach(ctrl => ctrl.style.display = 'inline-block');
        } else {
            editorControls.forEach(ctrl => ctrl.style.display = 'none');
        }
    }
    
    // Initialize graphing controls
    initGraphingControls() {
        // Chart type buttons
        const chartBtns = document.querySelectorAll('.chart-btn');
        chartBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                chartBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                const chartType = btn.dataset.chart;
                
                // Show/hide appropriate input sections
                if (chartType === 'function') {
                    document.getElementById('functionInputSection').style.display = 'block';
                    document.getElementById('chartDataSection').style.display = 'none';
                    document.getElementById('shapeParamsSection').style.display = 'none';
                    document.getElementById('shape3DControls').style.display = 'none';
                } else {
                    document.getElementById('functionInputSection').style.display = 'none';
                    document.getElementById('chartDataSection').style.display = 'block';
                    document.getElementById('shapeParamsSection').style.display = 'none';
                    document.getElementById('shape3DControls').style.display = 'none';
                }
            });
        });
        
        // Shape buttons
        const shapeBtns = document.querySelectorAll('.shape-btn');
        shapeBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const shape = btn.dataset.shape;
                
                // Hide chart sections, show shape section
                document.getElementById('functionInputSection').style.display = 'none';
                document.getElementById('chartDataSection').style.display = 'none';
                document.getElementById('shapeParamsSection').style.display = 'block';
                document.getElementById('shape3DControls').style.display = 'block';
                
                // Deactivate chart buttons
                chartBtns.forEach(b => b.classList.remove('active'));
                
                // Generate shape-specific inputs
                this.generateShapeInputs(shape);
            });
        });
        
        // Plot function button
        const plotBtn = document.getElementById('plotBtn');
        if (plotBtn) {
            plotBtn.addEventListener('click', () => {
                const funcStr = document.getElementById('functionInput').value;
                const xMin = parseFloat(document.getElementById('xMin').value);
                const xMax = parseFloat(document.getElementById('xMax').value);
                const yMin = parseFloat(document.getElementById('yMin').value);
                const yMax = parseFloat(document.getElementById('yMax').value);
                
                this.graphingController.plotFunction(funcStr, xMin, xMax, yMin, yMax);
            });
        }
        
        // Plot chart button
        const plotChartBtn = document.getElementById('plotChartBtn');
        if (plotChartBtn) {
            plotChartBtn.addEventListener('click', () => {
                const chartType = document.querySelector('.chart-btn.active')?.dataset.chart || 'bar';
                const labelsStr = document.getElementById('chartLabels').value;
                const valuesStr = document.getElementById('chartValues').value;
                
                const labels = labelsStr.split(',').map(s => s.trim());
                const values = valuesStr.split(',').map(s => parseFloat(s.trim()));
                
                this.graphingController.plotChart(chartType, labels, values);
            });
        }
        
        // Render shape button
        const renderShapeBtn = document.getElementById('renderShapeBtn');
        if (renderShapeBtn) {
            renderShapeBtn.addEventListener('click', () => {
                const shape = document.querySelector('.shape-btn:focus')?.dataset.shape || 
                             this.graphingController.currentShape;
                
                if (!shape) return;
                
                const params = this.collectShapeParams();
                this.graphingController.render3DShape(shape, params);
            });
        }
    }
    
    generateShapeInputs(shape) {
        const container = document.getElementById('shapeInputs');
        container.innerHTML = '';
        
        const inputs = {
            cube: [
                { name: 'size', label: window.t('lblSize'), value: 150, step: 10 }
            ],
            cuboid: [
                { name: 'width', label: window.t('lblWidth'), value: 180, step: 10 },
                { name: 'height', label: window.t('lblHeight'), value: 120, step: 10 },
                { name: 'depth', label: window.t('lblDepth'), value: 100, step: 10 }
            ],
            pyramid: [
                { name: 'baseSize', label: window.t('lblBaseSize'), value: 150, step: 10 },
                { name: 'height', label: window.t('lblHeight'), value: 180, step: 10 }
            ],
            cylinder: [
                { name: 'radius', label: window.t('lblRadius'), value: 80, step: 5 },
                { name: 'height', label: window.t('lblHeight'), value: 200, step: 10 }
            ],
            sphere: [
                { name: 'radius', label: window.t('lblRadius'), value: 100, step: 5 }
            ],
            cone: [
                { name: 'radius', label: window.t('lblRadius'), value: 80, step: 5 },
                { name: 'height', label: window.t('lblHeight'), value: 180, step: 10 }
            ]
        };
        
        const shapeInputs = inputs[shape] || [];
        shapeInputs.forEach(input => {
            const group = document.createElement('div');
            group.className = 'input-group';
            
            const label = document.createElement('label');
            label.textContent = input.label + ':';
            label.htmlFor = 'shape-' + input.name;
            
            const inputEl = document.createElement('input');
            inputEl.type = 'number';
            inputEl.id = 'shape-' + input.name;
            inputEl.name = input.name;
            inputEl.value = input.value;
            inputEl.step = input.step;
            
            // Add real-time update on input change
            inputEl.addEventListener('input', () => {
                const params = this.collectShapeParams();
                this.graphingController.render3DShape(shape, params);
            });
            
            group.appendChild(label);
            group.appendChild(inputEl);
            container.appendChild(group);
        });
        
        // Store current shape
        this.graphingController.currentShape = shape;
        
        // Auto-render the shape
        const params = this.collectShapeParams();
        this.graphingController.render3DShape(shape, params);
        
        // Setup 3D control listeners if not already set up
        this.setup3DControls();
    }
    
    setup3DControls() {
        // Rotation X
        const rotationX = document.getElementById('rotationX');
        const rotationXValue = document.getElementById('rotationXValue');
        if (rotationX && !rotationX.hasAttribute('data-listener')) {
            rotationX.setAttribute('data-listener', 'true');
            rotationX.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                rotationXValue.textContent = value + '¬∞';
                this.graphingController.setRotation(
                    value,
                    parseInt(document.getElementById('rotationY').value),
                    parseInt(document.getElementById('rotationZ').value)
                );
            });
        }
        
        // Rotation Y
        const rotationY = document.getElementById('rotationY');
        const rotationYValue = document.getElementById('rotationYValue');
        if (rotationY && !rotationY.hasAttribute('data-listener')) {
            rotationY.setAttribute('data-listener', 'true');
            rotationY.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                rotationYValue.textContent = value + '¬∞';
                this.graphingController.setRotation(
                    parseInt(document.getElementById('rotationX').value),
                    value,
                    parseInt(document.getElementById('rotationZ').value)
                );
            });
        }
        
        // Rotation Z
        const rotationZ = document.getElementById('rotationZ');
        const rotationZValue = document.getElementById('rotationZValue');
        if (rotationZ && !rotationZ.hasAttribute('data-listener')) {
            rotationZ.setAttribute('data-listener', 'true');
            rotationZ.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                rotationZValue.textContent = value + '¬∞';
                this.graphingController.setRotation(
                    parseInt(document.getElementById('rotationX').value),
                    parseInt(document.getElementById('rotationY').value),
                    value
                );
            });
        }
        
        // Zoom
        const zoomLevel = document.getElementById('zoomLevel');
        const zoomValue = document.getElementById('zoomValue');
        if (zoomLevel && !zoomLevel.hasAttribute('data-listener')) {
            zoomLevel.setAttribute('data-listener', 'true');
            zoomLevel.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                zoomValue.textContent = value + '%';
                this.graphingController.setZoom(value / 100);
            });
        }
        
        // Reset button
        const reset3DBtn = document.getElementById('reset3DBtn');
        if (reset3DBtn && !reset3DBtn.hasAttribute('data-listener')) {
            reset3DBtn.setAttribute('data-listener', 'true');
            reset3DBtn.addEventListener('click', () => {
                document.getElementById('rotationX').value = 30;
                document.getElementById('rotationXValue').textContent = '30¬∞';
                document.getElementById('rotationY').value = 45;
                document.getElementById('rotationYValue').textContent = '45¬∞';
                document.getElementById('rotationZ').value = 0;
                document.getElementById('rotationZValue').textContent = '0¬∞';
                document.getElementById('zoomLevel').value = 100;
                document.getElementById('zoomValue').textContent = '100%';
                this.graphingController.resetView();
            });
        }
    }
    
    collectShapeParams() {
        const params = {};
        const inputs = document.querySelectorAll('#shapeInputs input');
        inputs.forEach(input => {
            params[input.name] = parseFloat(input.value);
        });
        return params;
    }
    
    // Initialize transformation controls
    initTransformationControls() {
        // Shape selection buttons
        const shape2DBtns = document.querySelectorAll('.shape-2d-btn');
        shape2DBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                shape2DBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                const shape = btn.dataset.shape;
                
                if (shape === 'custom') {
                    document.getElementById('customPointsSection').style.display = 'block';
                } else {
                    document.getElementById('customPointsSection').style.display = 'none';
                    this.transformationsController.setShape(shape);
                }
            });
        });
        
        // Translation X
        const translationX = document.getElementById('translationX');
        const transXValue = document.getElementById('transXValue');
        if (translationX) {
            translationX.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                transXValue.textContent = value;
                this.transformationsController.setTranslation(
                    value,
                    parseFloat(document.getElementById('translationY').value)
                );
            });
        }
        
        // Translation Y
        const translationY = document.getElementById('translationY');
        const transYValue = document.getElementById('transYValue');
        if (translationY) {
            translationY.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                transYValue.textContent = value;
                this.transformationsController.setTranslation(
                    parseFloat(document.getElementById('translationX').value),
                    value
                );
            });
        }
        
        // Rotation
        const rotation2D = document.getElementById('rotation2D');
        const rotation2DValue = document.getElementById('rotation2DValue');
        if (rotation2D) {
            rotation2D.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                rotation2DValue.textContent = value + '¬∞';
                this.transformationsController.setRotation(value);
            });
        }
        
        // Scale
        const scale2D = document.getElementById('scale2D');
        const scaleValue = document.getElementById('scaleValue');
        if (scale2D) {
            scale2D.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                scaleValue.textContent = value;
                this.transformationsController.setScale(value);
            });
        }
        
        // Reflection buttons
        const reflectX = document.getElementById('reflectX');
        if (reflectX) {
            reflectX.addEventListener('click', () => {
                this.transformationsController.reflectX();
                this.resetTransformSliders();
            });
        }
        
        const reflectY = document.getElementById('reflectY');
        if (reflectY) {
            reflectY.addEventListener('click', () => {
                this.transformationsController.reflectY();
                this.resetTransformSliders();
            });
        }
        
        const reflectOrigin = document.getElementById('reflectOrigin');
        if (reflectOrigin) {
            reflectOrigin.addEventListener('click', () => {
                this.transformationsController.reflectOrigin();
                this.resetTransformSliders();
            });
        }
        
        const reflectYeqX = document.getElementById('reflectYeqX');
        if (reflectYeqX) {
            reflectYeqX.addEventListener('click', () => {
                this.transformationsController.reflectYeqX();
                this.resetTransformSliders();
            });
        }
        
        // Special transformations
        const shearX = document.getElementById('shearX');
        if (shearX) {
            shearX.addEventListener('click', () => {
                this.transformationsController.shearX();
                this.resetTransformSliders();
            });
        }
        
        const shearY = document.getElementById('shearY');
        if (shearY) {
            shearY.addEventListener('click', () => {
                this.transformationsController.shearY();
                this.resetTransformSliders();
            });
        }
        
        const rotate90 = document.getElementById('rotate90');
        if (rotate90) {
            rotate90.addEventListener('click', () => {
                this.transformationsController.rotate90();
                this.resetTransformSliders();
            });
        }
        
        const rotate180 = document.getElementById('rotate180');
        if (rotate180) {
            rotate180.addEventListener('click', () => {
                this.transformationsController.rotate180();
                this.resetTransformSliders();
            });
        }
        
        // Action buttons
        const showOriginal = document.getElementById('showOriginal');
        if (showOriginal) {
            showOriginal.addEventListener('click', () => {
                this.transformationsController.toggleOriginal();
            });
        }
        
        const showGrid = document.getElementById('showGrid');
        if (showGrid) {
            showGrid.addEventListener('click', () => {
                this.transformationsController.toggleGrid();
            });
        }
        
        const resetTransform = document.getElementById('resetTransform');
        if (resetTransform) {
            resetTransform.addEventListener('click', () => {
                this.transformationsController.resetAll();
                this.resetTransformSliders();
            });
        }
        
        // Custom points
        const applyPoints = document.getElementById('applyPoints');
        if (applyPoints) {
            applyPoints.addEventListener('click', () => {
                const pointsText = document.getElementById('customPoints').value;
                this.transformationsController.setCustomPoints(pointsText);
            });
        }
        
        // Rotation center controls
        const rotationCenterX = document.getElementById('rotationCenterX');
        const rotCenterXValue = document.getElementById('rotCenterXValue');
        if (rotationCenterX) {
            rotationCenterX.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                rotCenterXValue.textContent = value;
                this.transformationsController.setRotationCenter(
                    value,
                    parseFloat(document.getElementById('rotationCenterY').value)
                );
            });
        }
        
        const rotationCenterY = document.getElementById('rotationCenterY');
        const rotCenterYValue = document.getElementById('rotCenterYValue');
        if (rotationCenterY) {
            rotationCenterY.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                rotCenterYValue.textContent = value;
                this.transformationsController.setRotationCenter(
                    parseFloat(document.getElementById('rotationCenterX').value),
                    value
                );
            });
        }
        
        const setCenterToShape = document.getElementById('setCenterToShape');
        if (setCenterToShape) {
            setCenterToShape.addEventListener('click', () => {
                const centroid = this.transformationsController.setRotationCenterToShape();
                // Update slider values to match calculated centroid
                rotationCenterX.value = centroid.x;
                rotCenterXValue.textContent = centroid.x.toFixed(1);
                rotationCenterY.value = centroid.y;
                rotCenterYValue.textContent = centroid.y.toFixed(1);
            });
        }
    }
    
    resetTransformSliders() {
        document.getElementById('translationX').value = 0;
        document.getElementById('transXValue').textContent = '0';
        document.getElementById('translationY').value = 0;
        document.getElementById('transYValue').textContent = '0';
        document.getElementById('rotation2D').value = 0;
        document.getElementById('rotation2DValue').textContent = '0¬∞';
        document.getElementById('scale2D').value = 1;
        document.getElementById('scaleValue').textContent = '1';
        document.getElementById('rotationCenterX').value = 0;
        document.getElementById('rotCenterXValue').textContent = '0';
        document.getElementById('rotationCenterY').value = 0;
        document.getElementById('rotCenterYValue').textContent = '0';
    }
    
    // Initialize drawing controls
    initDrawingControls() {
        // Tool buttons
        const toolBtns = document.querySelectorAll('.tool-btn');
        toolBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                toolBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                const tool = btn.dataset.tool;
                this.drawingController.setTool(tool);
            });
        });
        
        // Color picker
        const drawingColor = document.getElementById('drawingColor');
        if (drawingColor) {
            drawingColor.addEventListener('input', (e) => {
                this.drawingController.setColor(e.target.value);
            });
        }
        
        // Brush size
        const brushSize = document.getElementById('brushSize');
        const brushSizeValue = document.getElementById('brushSizeValue');
        if (brushSize) {
            brushSize.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                brushSizeValue.textContent = value;
                this.drawingController.setBrushSize(value);
            });
        }
        
        // Background buttons
        const setBgWhite = document.getElementById('setBgWhite');
        if (setBgWhite) {
            setBgWhite.addEventListener('click', () => {
                this.drawingController.setBackgroundColor('#ffffff');
            });
        }
        
        const setBgBlack = document.getElementById('setBgBlack');
        if (setBgBlack) {
            setBgBlack.addEventListener('click', () => {
                this.drawingController.setBackgroundColor('#000000');
            });
        }
        
        const setBgTransparent = document.getElementById('setBgTransparent');
        if (setBgTransparent) {
            setBgTransparent.addEventListener('click', () => {
                this.drawingController.setBackgroundColor('transparent');
            });
        }
        
        // Action buttons
        const clearDrawing = document.getElementById('clearDrawing');
        if (clearDrawing) {
            clearDrawing.addEventListener('click', () => {
                if (confirm(window.t('msgClearCanvas'))) {
                    this.drawingController.clearCanvas();
                }
            });
        }
        
        const undoDrawing = document.getElementById('undoDrawing');
        if (undoDrawing) {
            undoDrawing.addEventListener('click', () => {
                this.drawingController.undo();
            });
        }
        
        const saveDrawing = document.getElementById('saveDrawing');
        if (saveDrawing) {
            saveDrawing.addEventListener('click', () => {
                this.drawingController.saveImage();
            });
        }
        
        // Grid controls
        const toggleGrid = document.getElementById('toggleGrid');
        if (toggleGrid) {
            toggleGrid.addEventListener('click', () => {
                this.drawingController.toggleGrid();
            });
        }
        
        const gridSize = document.getElementById('gridSize');
        const gridSizeValue = document.getElementById('gridSizeValue');
        if (gridSize) {
            gridSize.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                gridSizeValue.textContent = value;
                this.drawingController.setGridSize(value);
            });
        }
    }

    // Initialize evaluation
    initEvaluation() {
        const evaluateBtn = document.getElementById('evaluateBtn');
        if (evaluateBtn) {
            evaluateBtn.addEventListener('click', () => {
                this.evaluateExpression();
            });
        }
    }

    // Evaluate expression
    evaluateExpression() {
        const resultContainer = document.getElementById('evaluationResult');
        const resultValue = document.getElementById('resultValue');
        
        if (!resultContainer || !resultValue) return;
        
        try {
            let mathString = this.expression.toMathString();
            console.log('Evaluating:', mathString);
            
            if (!mathString || mathString.trim() === '') {
                resultContainer.style.display = 'none';
                return;
            }

            // Remove trailing equals sign if present
            mathString = mathString.trim();
            if (mathString.endsWith('=')) {
                mathString = mathString.slice(0, -1);
            }
            
            // Use pure JS to evaluate
            // Security note: new Function is safer than eval but still risky with user input
            // In a real app, we should sanitize or use a parser
            const result = new Function('return ' + mathString)();
            
            // Format result
            let formattedResult = result;
            if (typeof result === 'number') {
                // Limit decimal places to avoid floating point issues
                formattedResult = parseFloat(result.toPrecision(14));
                // Remove trailing zeros if integer
                if (Math.abs(formattedResult - Math.round(formattedResult)) < 1e-10) {
                    formattedResult = Math.round(formattedResult);
                }
            }
            
            resultValue.textContent = formattedResult;
            resultContainer.classList.remove('error');
            resultContainer.style.display = 'flex';
            
        } catch (error) {
            console.error('Evaluation error:', error);
            resultValue.textContent = error.message;
            resultContainer.classList.add('error');
            resultContainer.style.display = 'flex';
        }
    }

    // Initialize control buttons
    initControls() {
        const clearBtn = document.getElementById('clearBtn');
        const undoBtn = document.getElementById('undoBtn');
        const exportBtn = document.getElementById('exportBtn');
        const exportJpegBtn = document.getElementById('exportJpegBtn');
        const importJpegBtn = document.getElementById('importJpegBtn');
        const jpegFileInput = document.getElementById('jpegFileInput');

        if (clearBtn) {
            clearBtn.addEventListener('click', () => {
                this.expression.clear();
                this.navContext.clear();
                this.render();
            });
        }

        if (undoBtn) {
            undoBtn.addEventListener('click', () => {
                if (this.expression.undo()) {
                    this.navContext.clear();
                    this.render();
                }
            });
        }

        if (exportBtn) {
            exportBtn.addEventListener('click', () => {
                this.exportLatex();
            });
        }

        if (exportJpegBtn) {
            exportJpegBtn.addEventListener('click', () => {
                this.exportJpeg();
            });
        }

        if (importJpegBtn && jpegFileInput) {
            importJpegBtn.addEventListener('click', () => {
                jpegFileInput.click();
            });

            jpegFileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    this.importFromJpeg(file);
                }
                // Reset input so same file can be selected again
                jpegFileInput.value = '';
            });
        }

        // Latin letters expand/collapse button
        const expandLatinBtn = document.getElementById('expandLatinBtn');
        const allLatinLetters = document.getElementById('allLatinLetters');
        if (expandLatinBtn && allLatinLetters) {
            expandLatinBtn.addEventListener('click', () => {
                if (allLatinLetters.style.display === 'none') {
                    allLatinLetters.style.display = 'block';
                    expandLatinBtn.textContent = 'Show Less';
                } else {
                    allLatinLetters.style.display = 'none';
                    expandLatinBtn.textContent = 'Show All';
                }
            });
        }
    }

    // Initialize mouse click handling
    initMouseHandling() {
        this.displayElement.addEventListener('click', (e) => {
            this.handleDisplayClick(e);
        });
    }

    // Handle clicks on the expression display
    handleDisplayClick(event) {
        const target = event.target;
        
        // Check if clicked on a cursor
        if (target.classList.contains('cursor')) {
            const position = parseInt(target.dataset.position);
            if (!isNaN(position)) {
                this.setCursorPosition(position);
                this.render();
            }
            return;
        }

        // Check if clicked on a section (numerator, denominator, etc.)
        let sectionElement = target;
        while (sectionElement && sectionElement !== this.displayElement) {
            const section = sectionElement.dataset.section;
            if (section) {
                // Find the parent complex element
                const complexElement = this.findComplexElementForSection(sectionElement);
                if (complexElement) {
                    this.navContext.clear();
                    this.navContext.enter(complexElement.element, section);
                    
                    // Try to find cursor position within section
                    const cursorInSection = sectionElement.querySelector('.cursor');
                    if (cursorInSection && cursorInSection.dataset.position) {
                        this.navContext.currentPosition = parseInt(cursorInSection.dataset.position);
                    }
                    
                    this.render();
                    return;
                }
            }
            sectionElement = sectionElement.parentElement;
        }

        // If clicked on main display, move cursor to nearest position
        const clickX = event.clientX;
        const clickY = event.clientY;
        this.setCursorToNearestPosition(clickX, clickY);
    }

    // Find the complex element that contains this section
    findComplexElementForSection(sectionElement) {
        // Search through all elements to find matching one
        for (let i = 0; i < this.expression.elements.length; i++) {
            const element = this.expression.elements[i];
            if (this.isComplexElementType(element)) {
                // Check if this section belongs to this element
                const elementNode = this.displayElement.querySelector(`[data-element-index="${i}"]`);
                if (elementNode && elementNode.contains(sectionElement)) {
                    return { element, index: i };
                }
            }
        }
        return null;
    }

    // Check if element is a complex type
    isComplexElementType(element) {
        return element && (
            element.type === 'fraction' ||
            element.type === 'power' ||
            element.type === 'subscript' ||
            element.type === 'sqrt' ||
            element.type === 'parens'
        );
    }

    // Set cursor to nearest position based on click coordinates
    setCursorToNearestPosition(clickX, clickY) {
        const cursors = this.displayElement.querySelectorAll('.cursor');
        let nearestCursor = null;
        let minDistance = Infinity;

        cursors.forEach((cursor) => {
            const rect = cursor.getBoundingClientRect();
            const cursorX = rect.left + rect.width / 2;
            const cursorY = rect.top + rect.height / 2;
            
            const distance = Math.sqrt(
                Math.pow(clickX - cursorX, 2) + 
                Math.pow(clickY - cursorY, 2)
            );

            if (distance < minDistance) {
                minDistance = distance;
                nearestCursor = cursor;
            }
        });

        if (nearestCursor && nearestCursor.dataset.position) {
            const position = parseInt(nearestCursor.dataset.position);
            this.setCursorPosition(position);
            this.render();
        }
    }

    // Set cursor position
    setCursorPosition(position) {
        this.navContext.clear();
        this.expression.cursorPosition = position;
    }

    // Render the expression
    render() {
        if (!this.displayElement) return;

        // Clear display
        this.displayElement.innerHTML = '';

        // Render main expression
        if (this.navContext.isInsideElement()) {
            // Render with context awareness
            this.renderWithContext();
        } else {
            // Normal rendering
            this.renderMainExpression();
        }

        // Update navigation highlights
        // Note: We already add 'active' class during rendering, so we don't need
        // the NavigationRenderer to do it again. Comment this out to avoid conflicts.
        // const activePos = this.navigationSystem.getActivePosition();
        // if (activePos.type === 'section') {
        //     this.navRenderer.highlightActiveSection(activePos.section);
        // }

        // Update breadcrumbs
        const breadcrumbs = this.navigationSystem.getBreadcrumbs();
        this.navRenderer.updateBreadcrumbs(breadcrumbs);
    }

    // Render main expression
    renderMainExpression() {
        const fragment = document.createDocumentFragment();

        // Add cursor at start if position is 0
        if (this.expression.cursorPosition === 0) {
            fragment.appendChild(this.createCursor(true, 0));
        } else {
            fragment.appendChild(this.createCursor(false, 0));
        }

        // Render each element
        this.expression.elements.forEach((element, index) => {
            const elementNode = this.renderElement(element);
            fragment.appendChild(elementNode);

            // Add cursor after this element if needed
            const position = index + 1;
            if (this.expression.cursorPosition === position) {
                fragment.appendChild(this.createCursor(true, position));
            } else {
                fragment.appendChild(this.createCursor(false, position));
            }
        });

        this.displayElement.appendChild(fragment);
    }

    // Render with navigation context (inside complex element)
    renderWithContext() {
        const fragment = document.createDocumentFragment();

        // Add cursor at start if position is 0
        if (this.expression.cursorPosition === 0) {
            fragment.appendChild(this.createCursor(true, 0));
        } else {
            fragment.appendChild(this.createCursor(false, 0));
        }

        // Render each element, highlighting the active one
        this.expression.elements.forEach((element, index) => {
            const isActive = this.navContext.currentElement === element;
            const elementNode = this.renderElement(element, isActive);
            fragment.appendChild(elementNode);

            // Add cursor after this element
            const position = index + 1;
            const cursorActive = !this.navContext.isInsideElement() && 
                                 this.expression.cursorPosition === position;
            fragment.appendChild(this.createCursor(cursorActive, position));
        });

        this.displayElement.appendChild(fragment);
    }

    // Render a single element
    renderElement(element, isActive = false) {
        const container = document.createElement('span');
        container.classList.add('expr-element');
        
        if (isActive) {
            container.classList.add('focused');
        }

        // Store element index for click handling
        const elementIndex = this.expression.elements.indexOf(element);
        if (elementIndex >= 0) {
            container.dataset.elementIndex = elementIndex;
        }

        switch (element.type) {
            case 'number':
            case 'symbol':
                container.classList.add(`expr-${element.type}`);
                container.textContent = element.value;
                break;

            case 'operator':
                container.classList.add('expr-operator');
                const opSymbols = {
                    '+': '+',
                    '-': '‚àí',
                    '*': '√ó',
                    '/': '√∑',
                    '=': '='
                };
                container.textContent = opSymbols[element.value] || element.value;
                break;

            case 'fraction':
                this.renderFraction(container, element);
                break;

            case 'power':
                this.renderPower(container, element);
                break;

            case 'subscript':
                this.renderSubscript(container, element);
                break;

            case 'sqrt':
                this.renderSqrt(container, element);
                break;

            case 'function':
                container.classList.add('expr-function');
                container.textContent = element.value;
                break;

            case 'parens':
                this.renderParens(container, element);
                break;

            case 'linebreak':
                container.classList.add('expr-linebreak');
                container.style.flexBasis = '100%';
                container.style.height = '0';
                break;

            default:
                container.textContent = '?';
        }

        return container;
    }

    // Render fraction
    renderFraction(container, element) {
        container.classList.add('expr-fraction');

        // Check if this element is the currently active element
        // Use object identity - this works for nested elements too
        const isCurrentElement = this.navContext.currentElement === element;

        const numerator = document.createElement('div');
        numerator.classList.add('fraction-numerator');
        numerator.setAttribute('data-section', 'numerator');
        
        const isNumeratorActive = this.navContext.currentSection === 'numerator' && isCurrentElement;
        
        if (isNumeratorActive) {
            numerator.classList.add('active');
        }
        
        // Add empty class if no elements
        if (!element.numerator || element.numerator.length === 0) {
            numerator.classList.add('empty');
        }

        this.renderSection(numerator, element.numerator, isNumeratorActive);
        container.appendChild(numerator);

        const denominator = document.createElement('div');
        denominator.classList.add('fraction-denominator');
        denominator.setAttribute('data-section', 'denominator');
        
        const isDenominatorActive = this.navContext.currentSection === 'denominator' && isCurrentElement;
        
        if (isDenominatorActive) {
            denominator.classList.add('active');
        }
        
        // Add empty class if no elements
        if (!element.denominator || element.denominator.length === 0) {
            denominator.classList.add('empty');
        }

        this.renderSection(denominator, element.denominator, isDenominatorActive);
        container.appendChild(denominator);
    }

    // Render power (exponent)
    renderPower(container, element) {
        container.classList.add('expr-power');

        // Check if this element is the currently active element
        const isCurrentElement = this.navContext.currentElement === element;

        const base = document.createElement('span');
        base.classList.add('power-base');
        base.setAttribute('data-section', 'base');
        
        const isBaseActive = this.navContext.currentSection === 'base' && isCurrentElement;
        
        if (isBaseActive) {
            base.classList.add('active');
        }
        
        // Add empty class if no elements
        if (!element.base || element.base.length === 0) {
            base.classList.add('empty');
        }

        this.renderSection(base, element.base, isBaseActive);
        container.appendChild(base);

        const exponent = document.createElement('span');
        exponent.classList.add('power-exponent');
        exponent.setAttribute('data-section', 'exponent');
        
        const isExponentActive = this.navContext.currentSection === 'exponent' && isCurrentElement;
        
        if (isExponentActive) {
            exponent.classList.add('active');
        }
        
        // Add empty class if no elements
        if (!element.exponent || element.exponent.length === 0) {
            exponent.classList.add('empty');
        }

        this.renderSection(exponent, element.exponent, isExponentActive);
        container.appendChild(exponent);
    }

    // Render subscript
    renderSubscript(container, element) {
        container.classList.add('expr-subscript');

        // Check if this element is the currently active element
        const isCurrentElement = this.navContext.currentElement === element;

        const base = document.createElement('span');
        base.classList.add('subscript-base');
        base.setAttribute('data-section', 'base');
        
        const isBaseActive = this.navContext.currentSection === 'base' && isCurrentElement;
        
        if (isBaseActive) {
            base.classList.add('active');
        }
        
        // Add empty class if no elements
        if (!element.base || element.base.length === 0) {
            base.classList.add('empty');
        }

        this.renderSection(base, element.base, isBaseActive);
        container.appendChild(base);

        const index = document.createElement('span');
        index.classList.add('subscript-index');
        index.setAttribute('data-section', 'index');
        
        const isIndexActive = this.navContext.currentSection === 'index' && isCurrentElement;
        
        if (isIndexActive) {
            index.classList.add('active');
        }
        
        // Add empty class if no elements
        if (!element.index || element.index.length === 0) {
            index.classList.add('empty');
        }

        this.renderSection(index, element.index, isIndexActive);
        container.appendChild(index);
    }

    // Render square root
    renderSqrt(container, element) {
        container.classList.add('expr-sqrt');

        // Create a wrapper for the radical symbol
        const radicalWrapper = document.createElement('span');
        radicalWrapper.classList.add('sqrt-radical-wrapper');
        
        // Create SVG radical symbol that scales with content
        const svgNS = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(svgNS, "svg");
        svg.classList.add('sqrt-symbol');
        svg.setAttribute('viewBox', '0 0 30 50');
        svg.setAttribute('preserveAspectRatio', 'none');
        
        const path = document.createElementNS(svgNS, "path");
        // Path: gentle down diagonal, sharp up, then connect to horizontal line
        path.setAttribute('d', 'M 0 32 L 10 50 L 22 1 L 33 1');
        path.setAttribute('stroke', '#333');
        path.setAttribute('stroke-width', '3');
        path.setAttribute('fill', 'none');
        path.setAttribute('stroke-linecap', 'butt');
        path.setAttribute('stroke-linejoin', 'miter');
        
        svg.appendChild(path);
        radicalWrapper.appendChild(svg);
        container.appendChild(radicalWrapper);

        // Check if this element is the currently active element
        const isCurrentElement = this.navContext.currentElement === element;

        const content = document.createElement('span');
        content.classList.add('sqrt-content');
        content.setAttribute('data-section', 'content');
        
        const isContentActive = this.navContext.currentSection === 'content' && isCurrentElement;
        
        if (isContentActive) {
            content.classList.add('active');
        }
        
        // Add empty class if no elements
        if (!element.content || element.content.length === 0) {
            content.classList.add('empty');
        }

        this.renderSection(content, element.content, isContentActive);
        container.appendChild(content);
    }

    // Render parentheses
    renderParens(container, element) {
        container.classList.add('expr-parens');

        const open = document.createElement('span');
        open.textContent = '(';
        container.appendChild(open);

        // Check if this element is the currently active element
        const isCurrentElement = this.navContext.currentElement === element;

        const content = document.createElement('span');
        content.classList.add('parens-content');
        content.setAttribute('data-section', 'content');
        
        const isContentActive = this.navContext.currentSection === 'content' && isCurrentElement;
        
        if (isContentActive) {
            content.classList.add('active');
        }
        
        // Add empty class if no elements
        if (!element.content || element.content.length === 0) {
            content.classList.add('empty');
        }

        this.renderSection(content, element.content, isContentActive);
        container.appendChild(content);

        const close = document.createElement('span');
        close.textContent = ')';
        container.appendChild(close);
    }

    // Render a section (array of elements)
    renderSection(container, elements, isActiveSection = false) {
        if (!elements || elements.length === 0) {
            // Show placeholder cursor if this is the active section
            const cursor = this.createCursor(
                isActiveSection && this.navContext.currentPosition === 0,
                0
            );
            container.appendChild(cursor);
            return;
        }

        // Render cursor at start if needed
        if (isActiveSection && this.navContext.currentPosition === 0) {
            container.appendChild(this.createCursor(true, 0));
        } else {
            container.appendChild(this.createCursor(false, 0));
        }

        // Render each element in section
        elements.forEach((element, index) => {
            const elementNode = this.renderElement(element);
            container.appendChild(elementNode);

            // Add cursor after element if needed
            const position = index + 1;
            const cursorActive = isActiveSection && 
                                 this.navContext.currentPosition === position;
            container.appendChild(this.createCursor(cursorActive, position));
        });
    }

    // Create cursor element
    createCursor(isActive, position = 0) {
        const cursor = document.createElement('span');
        cursor.classList.add('cursor');
        cursor.dataset.position = position;
        if (isActive) {
            cursor.classList.add('active');
        }
        return cursor;
    }

    // Export to LaTeX
    exportLatex() {
        const latex = this.expression.toLatex();
        
        // Create a modal or alert with the LaTeX
        const message = latex || 'Expression is empty';
        
        // Copy to clipboard
        navigator.clipboard.writeText(message).then(() => {
            alert(window.t('msgLatexCopied') + message);
        }).catch(() => {
            alert(window.t('lblLatex') + ':\n\n' + message);
        });
    }

    // Export to JPEG
    async exportJpeg() {
        if (!this.displayElement) {
            alert(window.t('msgDisplayNotFound'));
            return;
        }

        if (this.expression.elements.length === 0) {
            alert(window.t('msgExprEmptyCreate'));
            return;
        }

        try {
            // Temporarily hide cursors for export
            const cursors = this.displayElement.querySelectorAll('.cursor');
            cursors.forEach(cursor => {
                cursor.style.display = 'none';
            });

            // Remove focus highlights for cleaner export
            const focused = this.displayElement.querySelectorAll('.focused');
            focused.forEach(el => {
                el.classList.remove('focused');
            });

            const active = this.displayElement.querySelectorAll('.active');
            active.forEach(el => {
                el.classList.remove('active');
            });

            // Hide all dotted borders by temporarily removing them
            const borderedElements = this.displayElement.querySelectorAll(
                '.fraction-numerator, .fraction-denominator, ' +
                '.power-base, .power-exponent, ' +
                '.subscript-base, .subscript-index, ' +
                '.parens-content'
            );
            const originalBorders = [];
            borderedElements.forEach(el => {
                // Save original border styles
                originalBorders.push({
                    left: el.style.borderLeft,
                    right: el.style.borderRight,
                    top: el.style.borderTop,
                    bottom: el.style.borderBottom
                });
                // Hide side and top dotted borders
                el.style.borderLeft = 'none';
                el.style.borderRight = 'none';
                el.style.borderTop = 'none';
                // Hide bottom border except for fraction-numerator (which has the fraction line)
                if (!el.classList.contains('fraction-numerator')) {
                    el.style.borderBottom = 'none';
                }
            });
            
            // For sqrt-content, hide only the side/bottom borders but keep the top border
            const sqrtContents = this.displayElement.querySelectorAll('.sqrt-content');
            const originalSqrtBorders = [];
            sqrtContents.forEach(el => {
                originalSqrtBorders.push({
                    left: el.style.borderLeft,
                    right: el.style.borderRight,
                    bottom: el.style.borderBottom
                });
                el.style.borderLeft = 'none';
                el.style.borderRight = 'none';
                el.style.borderBottom = 'none';
            });

            // Use html2canvas to capture the expression
            const canvas = await html2canvas(this.displayElement, {
                backgroundColor: '#fafafa',
                scale: 2, // Higher quality
                logging: false,
                width: this.displayElement.scrollWidth,
                height: this.displayElement.scrollHeight
            });

            // Restore borders
            borderedElements.forEach((el, index) => {
                el.style.borderLeft = originalBorders[index].left;
                el.style.borderRight = originalBorders[index].right;
                el.style.borderTop = originalBorders[index].top;
                el.style.borderBottom = originalBorders[index].bottom;
            });
            
            // Restore sqrt borders
            sqrtContents.forEach((el, index) => {
                el.style.borderLeft = originalSqrtBorders[index].left;
                el.style.borderRight = originalSqrtBorders[index].right;
                el.style.borderBottom = originalSqrtBorders[index].bottom;
            });

            // Get LaTeX representation
            const latex = this.expression.toLatex();

            // Convert canvas to base64 data URL
            const dataUrl = canvas.toDataURL('image/jpeg', 0.95);
            
            // Convert data URL to blob with embedded LaTeX metadata
            // We'll embed LaTeX in the JPEG comment segment
            fetch(dataUrl)
                .then(res => res.blob())
                .then(blob => {
                    return blob.arrayBuffer();
                })
                .then(arrayBuffer => {
                    // Convert to Uint8Array for manipulation
                    const bytes = new Uint8Array(arrayBuffer);
                    
                    // Create comment marker (0xFFFE) with LaTeX data
                    const latexBytes = new TextEncoder().encode(latex);
                    const commentMarker = new Uint8Array([
                        0xFF, 0xFE, // COM marker
                        (latexBytes.length + 2) >> 8, // Length high byte
                        (latexBytes.length + 2) & 0xFF, // Length low byte
                        ...latexBytes
                    ]);
                    
                    // Insert comment after JPEG header (after SOI marker 0xFFD8)
                    const newBytes = new Uint8Array(bytes.length + commentMarker.length);
                    newBytes.set(bytes.slice(0, 2), 0); // Copy SOI marker
                    newBytes.set(commentMarker, 2); // Insert comment
                    newBytes.set(bytes.slice(2), 2 + commentMarker.length); // Copy rest
                    
                    // Create blob from modified bytes
                    const finalBlob = new Blob([newBytes], { type: 'image/jpeg' });
                    
                    // Create download link
                    const url = URL.createObjectURL(finalBlob);
                    const link = document.createElement('a');
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                    link.download = `math-expression-${timestamp}.jpg`;
                    link.href = url;
                    link.click();

                    // Clean up
                    URL.revokeObjectURL(url);

                    // Show cursors again
                    cursors.forEach(cursor => {
                        cursor.style.display = '';
                    });

                    // Restore highlights
                    this.render();
                })
                .catch(error => {
                    console.error('Failed to embed metadata:', error);
                    alert(window.t('msgExportFailed'));
                    
                    // Show cursors again
                    cursors.forEach(cursor => {
                        cursor.style.display = '';
                    });
                    this.render();
                });

        } catch (error) {
            console.error('Export failed:', error);
            alert(window.t('msgExportFailed'));
            
            // Show cursors again in case of error
            const cursors = this.displayElement.querySelectorAll('.cursor');
            cursors.forEach(cursor => {
                cursor.style.display = '';
            });
            this.render();
        }
    }

    async importFromJpeg(file) {
        try {
            // Read file as array buffer
            const arrayBuffer = await file.arrayBuffer();
            const bytes = new Uint8Array(arrayBuffer);
            
            // Look for COM marker (0xFFFE) after SOI (0xFFD8)
            let latex = null;
            for (let i = 2; i < bytes.length - 4; i++) {
                if (bytes[i] === 0xFF && bytes[i + 1] === 0xFE) {
                    // Found COM marker
                    const length = (bytes[i + 2] << 8) | bytes[i + 3];
                    const commentBytes = bytes.slice(i + 4, i + 2 + length);
                    latex = new TextDecoder().decode(commentBytes);
                    break;
                }
            }
            
            if (!latex) {
                alert(window.t('msgNoLatexMeta'));
                return;
            }
            
            // Parse and import the LaTeX
            console.log('Found LaTeX:', latex);
            
            // Clear current expression
            this.expression.clear();
            this.navContext.clear();
            
            // Parse LaTeX and rebuild expression
            this.parseLatex(latex);
            this.render();
            
            //alert('Expression imported successfully!');
            
        } catch (error) {
            console.error('Import failed:', error);
            alert(window.t('msgImportFailed') + error.message);
        }
    }

    parseLatex(latex) {
        // Remove outer $ signs if present
        latex = latex.trim().replace(/^\$+|\$+$/g, '');
        
        let pos = 0;
        
        const parseToken = () => {
            if (pos >= latex.length) return null;
            
            // Skip whitespace
            while (pos < latex.length && latex[pos] === ' ') pos++;
            
            if (pos >= latex.length) return null;
            
            const char = latex[pos];
            
            // Handle wrapped expressions {content}
            if (char === '{') {
                pos++; // skip {
                let depth = 1;
                while (pos < latex.length && depth > 0) {
                    if (latex[pos] === '{') depth++;
                    if (latex[pos] === '}') {
                        depth--;
                        if (depth === 0) break;
                    }
                    parseToken();
                }
                pos++; // skip closing }
                return 'group';
            }
            
            // Numbers
            if (char >= '0' && char <= '9') {
                pos++;
                this.keyboardController.insertElement(ElementFactory.createNumber(char));
                this.render();
                return 'number';
            }
            
            // Variables (single letters)
            if ((char >= 'a' && char <= 'z') || (char >= 'A' && char <= 'Z')) {
                // Check if it's a command
                if (latex[pos] === '\\') {
                    return parseCommand();
                }
                pos++;
                this.keyboardController.insertElement(ElementFactory.createSymbol(char));
                this.render();
                return 'variable';
            }
            
            // Special symbols (literal characters)
            if (char === '¬±') {
                pos++;
                this.keyboardController.insertElement(ElementFactory.createSymbol('¬±'));
                this.render();
                return 'symbol';
            }
            
            // Operators
            if (char === '+' || char === '-' || char === '*' || char === '=') {
                pos++;
                this.keyboardController.insertElement(ElementFactory.createOperator(char));
                this.render();
                return 'operator';
            }
            
            // Division
            if (latex.substr(pos, 5) === '\\div ') {
                pos += 5;
                this.keyboardController.insertElement(ElementFactory.createOperator('/'));
                this.render();
                return 'operator';
            }
            
            // Division (alternative)
            if (latex.substr(pos, 4) === '\\div') {
                pos += 4;
                this.keyboardController.insertElement(ElementFactory.createOperator('/'));
                this.render();
                return 'operator';
            }
            
            // Times
            if (latex.substr(pos, 6) === '\\times') {
                pos += 6;
                this.keyboardController.insertElement(ElementFactory.createOperator('*'));
                this.render();
                return 'operator';
            }
            
            // Plus-minus
            if (latex.substr(pos, 3) === '\\pm') {
                pos += 3;
                this.keyboardController.insertElement(ElementFactory.createSymbol('¬±'));
                this.render();
                return 'symbol';
            }
            
            // Line break
            if (latex.substr(pos, 2) === '\\\\') {
                pos += 2;
                this.keyboardController.insertElement(ElementFactory.createLineBreak());
                this.render();
                return 'linebreak';
            }
            
            // Fraction
            if (latex.substr(pos, 5) === '\\frac') {
                pos += 5;
                return parseFraction();
            }
            
            // Power
            if (char === '^') {
                pos++;
                return parsePower();
            }
            
            // Subscript
            if (char === '_') {
                pos++;
                return parseSubscript();
            }
            
            // Square root
            if (latex.substr(pos, 5) === '\\sqrt') {
                pos += 5;
                return parseSqrt();
            }
            
            // Parentheses
            if (char === '(') {
                pos++;
                this.keyboardController.handleFunction('parens');
                return 'paren-open';
            }
            
            if (char === ')') {
                pos++;
                if (this.navContext.currentElement && this.navContext.currentElement.type === 'parens') {
                    this.navContext.exit();
                    this.render();
                }
                return 'paren-close';
            }
            
            // Left and right parentheses commands
            if (latex.substr(pos, 6) === '\\left(') {
                pos += 6;
                this.keyboardController.handleFunction('parens');
                return 'paren-open';
            }
            
            if (latex.substr(pos, 7) === '\\right)') {
                pos += 7;
                if (this.navContext.currentElement && this.navContext.currentElement.type === 'parens') {
                    this.navContext.exit();
                    this.render();
                }
                return 'paren-close';
            }
            
            // Skip unknown characters
            pos++;
            return parseToken();
        };
        
        const parseFraction = () => {
            // \frac{numerator}{denominator}
            // Expect {
            if (latex[pos] !== '{') return null;
            pos++; // skip {
            
            // Add fraction
            this.keyboardController.handleFunction('fraction');
            
            // Parse numerator (already in numerator after creation)
            let depth = 1;
            while (pos < latex.length && depth > 0) {
                if (latex[pos] === '{') depth++;
                if (latex[pos] === '}') {
                    depth--;
                    if (depth === 0) break;
                }
                parseToken();
            }
            pos++; // skip closing }
            
            // Expect {
            if (latex[pos] !== '{') return null;
            pos++; // skip {
            
            // Move to denominator
            this.keyboardController.handleArrowDown();
            
            // Parse denominator
            depth = 1;
            while (pos < latex.length && depth > 0) {
                if (latex[pos] === '{') depth++;
                if (latex[pos] === '}') {
                    depth--;
                    if (depth === 0) break;
                }
                parseToken();
            }
            pos++; // skip closing }
            
            // Exit fraction
            this.navContext.exit();
            this.render();
            return 'fraction';
        };
        
        const parsePower = () => {
            // ^{exponent} or ^x
            // Need to be at main expression level for power to work correctly
            if (this.navContext.isInsideElement()) {
                // Exit to main level first
                while (this.navContext.isInsideElement()) {
                    this.navContext.exit();
                }
                this.render();
            }
            
            this.keyboardController.handleFunction('power');
            
            if (latex[pos] === '{') {
                pos++; // skip {
                let depth = 1;
                while (pos < latex.length && depth > 0) {
                    if (latex[pos] === '{') depth++;
                    if (latex[pos] === '}') {
                        depth--;
                        if (depth === 0) break;
                    }
                    parseToken();
                }
                pos++; // skip closing }
            } else {
                // Single character exponent
                parseToken();
            }
            
            this.navContext.exit();
            this.render();
            return 'power';
        };
        
        const parseSubscript = () => {
            // _{subscript} or _x
            // Need to be at main expression level for subscript to work correctly
            if (this.navContext.isInsideElement()) {
                // Exit to main level first
                while (this.navContext.isInsideElement()) {
                    this.navContext.exit();
                }
                this.render();
            }
            
            this.keyboardController.handleFunction('subscript');
            
            if (latex[pos] === '{') {
                pos++; // skip {
                let depth = 1;
                while (pos < latex.length && depth > 0) {
                    if (latex[pos] === '{') depth++;
                    if (latex[pos] === '}') {
                        depth--;
                        if (depth === 0) break;
                    }
                    parseToken();
                }
                pos++; // skip closing }
            } else {
                // Single character subscript
                parseToken();
            }
            
            this.navContext.exit();
            this.render();
            return 'subscript';
        };
        
        const parseSqrt = () => {
            // \sqrt{content}
            // Expect {
            if (latex[pos] !== '{') return null;
            pos++; // skip {
            
            // Add sqrt
            this.keyboardController.handleFunction('sqrt');
            
            // Parse content (already inside sqrt after creation)
            let depth = 1;
            while (pos < latex.length && depth > 0) {
                if (latex[pos] === '{') depth++;
                if (latex[pos] === '}') {
                    depth--;
                    if (depth === 0) break;
                }
                parseToken();
            }
            pos++; // skip closing }
            
            this.navContext.exit();
            this.render();
            return 'sqrt';
        };
        
        // Parse entire expression
        while (pos < latex.length) {
            parseToken();
        }
    }
}

// Initialize the app when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    const app = new MathExpressionApp();
    app.init();
});
    </script>
</body>
</html>
